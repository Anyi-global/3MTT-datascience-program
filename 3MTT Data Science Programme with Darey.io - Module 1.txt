3MTT DATA SCIENCE PROGRAMME WITH DAREY.IO (https://3mtt.academy.darey.io/)


MODULE 1
COURSE 1:
INTRODUCTION TO DATA AND DATA SCIENCE

In this project, you will embark on an exploration of data science, focusing on understanding the nature of data and the methodologies used to extract meaningful insights from it. This initiative aims to bridge the theoretical knowledge with practical application, enhancing your ability to analyze and interpret data effectively.


COURSE 2:
WHAT REALLY IS DATA SCIENCE?

Data science is not about making complicated models, It's not about making awesome visualizations. It's not about writing code, data science is about using data to create as much impact as possible for your company. Find out what it really means to be a data scientist.

According to IBM (2025), Data Science combines math and statistics, specialized programming, advanced analytics, artificial intelligence (AI), and machine learning with specific subject matter expertise to uncover actionable insights hidden in an organization's data decision main gand strategic planning.


COURSE 3:
PROGRAMMING BASICS
INTRODUCTION TO PYTHON
# Introduction to Python

Python is a versatile and beginner-friendly programming language, created by [Guido van RossumðŸ‘‡]

The name "Python" is a tribute to the British comedy group [Monty Python], reflecting its emphasis on readability and simplicity.

Since its inception, Python has gained immense popularity due to its broad applicability.

From the image, we see that Python can be used in various domains, including:

- Web Development: Frameworks like Django and Flask streamline the creation of dynamic web applications.
- Data Science and Machine Learning: Libraries like NumPy, Pandas, and Scikit-learn provide powerful tools for data analysis and model building.   
- Scientific Computing: used in fields like physics, chemistry, and engineering for numerical simulations and data visualization.
- Automation: Python scripts can automate repetitive tasks, saving time and effort.
- Game Development: Libraries like Pygame enable the creation of engaging games.

Python's active and supportive [community] contributes to its continued growth and innovation.

Now, we have an overview of what python is, next, we would consider the building blocks of the python programming language. They are referred to as the building blocks because it is the foundation on which the language can function properly.

Access to this Article: https://colab.research.google.com/drive/1wBp8rH4VZ0y3ahTRuBMHPZSerw0qV4V0#scrollTo=8fce7e5b

To run your python codes, you need environments that support your agenda. Some of the environments we would be using include the Anaconda distribution for your local device and Google Colab, a virtual machine.

Anaconda
Anaconda is a distribution of the Python for scientific computing, that aims to simplify package management and deployment. The distribution includes data-science packages suitable for Windows, Linux, and macOS. You can install and download Anaconda Distribution via https://www.anaconda.com/products/individual#windows for Windows and https://www.anaconda.com/download/success for MacOS.

After download, an Anaconda Navigator is installed on your local device. Anaconda Navigator is a desktop graphical user interface (GUI) included in Anaconda distribution that allows users to launch applications without using command-line commands. It looks something like thisðŸ‘‡

You can launch Anaconda Navigator by typing Anaconda Navigator on the search bar, then double click on the Anaconda Navigator (Anconda3) in Windows or by looking for "Anaconda-Navigator" among your MacOS apps after installation.

Among the applications present in the Anaconda are JupyterLab and Notebook. Both can be used for data science and analytics tasks. What makes them different though?

- Jupyter Notebook is best for straightforward data exploration and individual notebook workflows.
- JupyterLab is ideal for more complex workflows, multitasking, and team collaboration, offering a richer, more extensible, IDE-like experience.

For this course, we would use the Jupyter notebook.

Google Colab
Google Colab or Colab for short is a web-based platform that allows anybody you to write and execute Python code through the browser free of charge. It is a specialized version of the Jupyter Notebook, which runs on the cloud and offers free but limited computing resources.

It requires no setup to use while providing free access to computing resources including GPUs. You can also collaborate with others or share your completed work with other developers. You can access Colab via https://colab.research.google.com


A. PYTHON VARIABLES
If you grew up in a traditional home, you would know ice-cream containers werenâ€™t just used for ice cream. Often, youâ€™d open the freezer expecting to find some delicious vanilla or chocolate ice cream, only to discover... stew, beans, or soup!

The same way that those containers stored different things (ice cream, soup, etc.), variables in Python are like containers that store data.

You can give a variable a name, and inside it, you can store a piece of data like a number, text, or even more complex things like lists.

The variable is simply a way to label and hold something so you can refer to it later.

In Python, it stores information (data) that you might want to use or manipulate later in your code. For example, you might want to store your age, a name, or the price of a product.

Key things to remember:

A variable can hold different data types (numbers, text, etc.).

You can change what's inside the variable just like how, the ice-cream container can be reused for stew or soup.

Variables help make your code easier to read and manage by letting you refer to data with names you choose.

How to Create a Variable?
In Python, creating (or defining) a variable is super simple! You just choose a name for your variable and use the = symbol to assign a value to it.

# Example
## Let's store an age in a variable
age = 25

Rules for Naming Variables
Just like how we label our ice-cream containers with something meaningful like "ice cream" or "soup," variable names in Python should be clear and descriptive. But there are some rules:

Start with a letter or underscore (_). You canâ€™t start with a number.

     - Valid: name, _age
     - Invalid: 1name, @score
Only use letters, numbers, and underscores (_). No spaces or symbols like !, #, or @.

     - Valid: total_amount, student_name_2
     - Invalid: total-amount, !student name
Avoid Python keywords like "for", "if", and "else". These have special meanings in Python.

Case-sensitive: Python treats uppercase and lowercase letters as different. So, Name and name are two different variables.

# Example:
name = "Darey"
print(name)

The code returns an error when run - a NameError. Let's adjust the code and run.

P.S The print statement is used to display output in the console. It allows you to see the result of your code.

print(name)
Darey

E. Keep names descriptive: Itâ€™s a good practice to name your variables something meaningful. Instead of x, y, or a, use names like student_name, total_price, or is_sunny.

#Example:

##clear and descriptive
student_age = 18

##hard to understand
s_a = 18

Variable data types
Variables can be used to store different Data - Types.

Numbers
Variables can store numbers like integers (whole numbers) or floats (decimals).

# Storing an integer (whole number)
number_of_apples = 10

# Storing a float (decimal number)
price_of_icecream = 3.99

Strings
In python, we use single quotation marks (' ') or double quotation marks (" ") to denote text.

#without quotation marks

favorite_flavor = Vanilla

NameError                                 Traceback (most recent call last)
<ipython-input-6-35181a14d928> in <cell line: 0>()
      1 #without quotation marks
      2 
----> 3 favorite_flavor = Vanilla

NameError: name 'Vanilla' is not defined


We end up with a NameError which provides more information saying that Vanilla is not defined. Asides numbers and booleans, you must enclose text or sentences in quotation marks for python to understand what you're trying to say.

# Storing a string (text)

favorite_flavor = "Vanilla"

favorite_flavor is a variable that holds the text "Vanilla".

Boolean
# Storing a boolean value

is_icecream_available = True

is_icecream_available stores a boolean value, indicating that ice-cream is available.

Reusing Variables: Changing Whatâ€™s in the Container
Remember how the ice-cream container sometimes had your favourite soup instead of ice cream? In the same way, we can change the value stored in a variable.

# First, the container holds a number
quantity = 5

# Now we change the value in the same container (variable).
quantity = 10

#we simply reassigned the quantity to a different value

# Output the value of quantity
print(quantity)

10

The variable quantity first holds 5, but then we change it to 10. When we print it out, it shows 10.

The variable quantity first holds 5, but then we change it to 10. When we print it out, it shows 10.


### Benefits of Using Variables in Python
`1. Store Data`

Instead of repeating values throughout your code, you can store them in a variable.

Example: If the price of ice cream is 3.99, you donâ€™t want to write 3.99 in multiple places. Just use price_of_icecream.

`2. Makes Your Code Clear`

By using meaningful variable names, your code becomes easier to understand.

Example: total_cost is easier to understand than just writing numbers.

`3. Change Data Easily`

If the data changes (like the price of an item), you only have to update it in one place if it's stored in a variable.

Example: sale_price = #300 and gets updated to #540, you only have to change this in your variable and not for every instance sale_price was used in your code.


### Practical Example: Using Variables to Calculate a Total Price

Letâ€™s imagine you run a small ice-cream shop, and you want to calculate the total cost of a few items a customer buys.

# Variables to store prices of different items

price_of_vanilla_icecream = 10.00
price_of_chocolate_icecream = 3.00
price_of_cone = 0.75

You created variables for the unit prices of vanilla ice cream, chocolate ice cream, and cones.

# Variable to store the number of items
number_of_vanilla = 2
number_of_chocolate = 1
number_of_cones = 3

You also created variables to store how many of each item the customer is buying.

# Calculate the total cost
# We need to multiply
total_cost = (price_of_vanilla_icecream * number_of_vanilla) + (price_of_chocolate_icecream * number_of_chocolate) + (price_of_cone * number_of_cones)

# Output the total cost
print("The total cost is:", total_cost)

The total cost is: 25.25

Finally, you used the variables to calculate the total cost by first multiplying the cost of just a single ice cream flavor and the total quantity bought by your new customer, before addition.

Tada!! The total cost is 10.25.

Did you notice the "The total cost is:" part of the print statement? This is known as print formatting.


Print formatting
As we know, if you want to see the output of your code in Python, you have to speak to python in a language that it understands in this case, using the keyword: "print" (more on python keywords later).

Print formatting refers to the techniques used to format and present this output in a clear and structured way. There are several methods for achieving print formatting, including

String concatenation
The % operator
.format()
f-strings (formatted string literals).
a) String Concatenation:
This method uses the + operator to join strings together.


# Example:
dish = "Jollof Rice"
occasion = "birthday"
print("For my "+ occasion + " we will serve " + dish)


#print("For the " + occasion + ", we will serve delicious " + dish + ".")

For my birthday we will serve Jollof Rice

b) % Operator:
This classic method allows you to format strings with the % operator.

#Example:
artist = "Burna Boy"
album = "Twice as Tall"
print("The latest album by %s is titled %s" %(artist, album))


#print("The latest album by %s is titled %s." % (artist, album))

#The %d is  like an icon used to represent different types of items.

#Example:
artist = "Burna Boy"
album = "Twice as Tall"
print("The latest album by %s is titled %s" %(artist, album))


#print("The latest album by %s is titled %s." % (artist, album))

#The %d is  like an icon used to represent different types of items.
The latest album by Burna Boy is titled Twice as Tall
Commonly Used Icons/Placeholders:

%s is used to represent strings
%d is used to represent integers
%f is used to represent floats
%r is used to represent debugging representation.

 .format() Method:
This versatile method uses curly braces {} as placeholders.


[ ]
# Example:
festival = "Eid"
year = 2023
location = "Abuja"
print("The celebration of {} in {} is set for the year {}.".format(festival, location, year))
The celebration of Eid in Abuja is set for the year 2023.

d) f-strings (Formatted String Literals):
This modern method allows for inline expressions within curly braces.


[ ]
#Example:
sport = "football"
team = "Super Eagles"
rank = 3
print(f"The {team} are currently ranked {rank} in the world for {sport}")

#print(f"The {team} are currently ranked {rank} in the world for {sport}.")
The Super Eagles are currently ranked 3 in the world for football
Understanding and leveraging these print formatting methods will enable you to present information in a more organized and engaging manner. By choosing the method that best fits your style, you can make your python programs and outputs not only functional but also appealing to the audience.


B. DATA TYPES AND DATA STRUCTURES
DATA STRUCTURES
We have primitive or data types and non-primitive data structures. Primitive data structures are; Float, Integer, String, and Boolean. 

Non-primitive data structure is divided into two types; Built-in and User-defined.

Example of Built-in data structure are; List, Tuple, Dictionary, and Set.

Example of User-defined data structure are; Stack, Queue, LinkedList, Tree, and Heap.

Link to access the tutorial: https://colab.research.google.com/drive/1LkInhGiBgf9VMJ-e_j5itSJcqI-4e7kT


C. PYTHON OPERATORS
In Python, operators are special symbols, keywords that are used to perform operations on variables and values. Think of operators as instructions that allow you to carry out tasks like arithmetic calculations, comparisons, and making decisions in your code.

List of Python Operators
- Arithmetic Operators â€“ Used for basic mathematical operations.
- Comparison (Relational) Operators â€“ Used to compare two values.
- Logical Operators â€“ Used to combine conditional statements.
- Assignment Operators â€“ Used to assign values to variables.
- Identity Operators â€“ Used to compare the memory locations of two objects.
- Membership Operators â€“ Used to check if a value is part of a sequence (like a list or a string).


1. ARITHMETIC OPERATORS
These operators allow you to perform basic math operations like addition, subtraction, multiplication, and division.

Imagine youâ€™re managing your personal finances. You can use arithmetic operators to track your income, expenses, and calculate your savings.

List of Arithmetic Operators:
- Addition (+): Adds two numbers.
- Subtraction (-): Subtracts one number from another.
- Multiplication (*): Multiplies two numbers.
- Division (/): Divides one number by another.
- Modulus (%): Returns the remainder when one number is divided by another.
- Exponentiation (``)**: Raises one number to the power of another.
- Floor Division (//): Divides two numbers and rounds down to the nearest integer.


2. RELATIONAL OPERATORS
They allow you to compare two values and determine their relationship to one another. Here's a detailed explanation of each operator:

List of Operators:
i. Equal to (==):

- Checks whether two values are identical.
- Returns True if both values are the same; otherwise, returns False.
- Example: 5 == 5 is True, while 5 == 3 is False.

ii. Not equal to (!=):

- Determines whether two values are different.
- Returns True if the values are not the same; returns False if they are identical.
- Example: 5 != 3 is True, while 5 != 5 is False.

iii. Greater than (>):

- Checks if the value on the left is larger than the value on the right.
- Returns True if it is; otherwise, returns False.
- Example: 7 > 5 is True, but 3 > 5 is False.

iv. Less than (<):

- Checks if the value on the left is smaller than the value on the right.
- Returns True if it is; otherwise, returns False.
- Example: 4 < 6 is True, but 6 < 4 is False.

v. Greater than or equal to (>=):

- Checks if the value on the left is either greater than or equal to the value on the right.
- Returns True if either condition is met.
- Example: 5 >= 5 is True, 6 >= 5 is also True, while 4 >= 5 is False.

vi. Less than or equal to (<=):

- Checks if the value on the left is either less than or equal to the value on the right.
- Returns True if either condition holds.
- Example: 5 <= 5 is True, 4 <= 5 is also True, while 6 <= 5 is `False


3. LOGICAL OPERATORS
Used to combine multiple conditions in programming. They help us make decisions based on whether certain conditions are met.

Example 1: Using the and Operator

Scenario: You walk into a grocery store and want to purchase both bread and peanut butter. You will only make a purchase if both items are available.


Example 1: Using the and Operator

Scenario: You walk into a grocery store and want to purchase both bread and peanut butter. You will only make a purchase if both items are available.

# Check availability of items
bread_available = True
peanut_butter_available = False

# Again, copy this code and observe the result
# Use 'and' to check if both items are available

if bread_available and peanut_butter_available:
    print("You can buy both bread and peanut butter.")
else:
    print("One or both items are not available.")

OUTPUT
One or both items are not available.

Example 2: Using the or Operator

Scenario: You are planning a weekend activity. You can either go to the movies or to the park. You will go out if at least one of them is open.

# Check if places are open
movies_open = False
park_open = True

# Use 'or' to check if at least one place is open
if movies_open or park_open:
    print("You can go out this weekend!")
else:
    print("Both places are closed.")

OUTPUT
You can go out this weekend!

Using The 'Not' Operator
# Check the weather condition; is it raining
is_raining = False
# False means it is not raining

# `not` negates, that is it gives you the opposite of a task;
can_we_go_for_picnic = not is_raining

# Print the result
print("Can we go for a picnic?", can_we_go_for_picnic)

OUTPUT
Can we go for a picnic? True


4. ASSIGNMENT OPERATORS
Used to assign values to variables. While you've already used the = operator to assign a value, there are several other operators that help you update variables by performing operations in a single step.

List of Operators:
i. = (Assign):

This operator assigns a value to a variable.
Example: x = 10 assigns the value 10 to the variable x.
+= (Add and Assign):

This operator adds a value to a variable and assigns the result back to that variable.
Example:
x = 5
x += 3  # Equivalent to x = x + 3

print(x)

ii. -= (Subtract and Assign):
This operator subtracts a value from a variable and assigns the result back to that variable.
Example:
x = 10
x -= 4  # Equivalent to x = x - 4
print(x)

iii. *= (Multiply and Assign):
This operator multiplies a variable by a value and assigns the result back to that variable.
Example:
x = 3
x *= 4  # Equivalent to x = x * 4
print(x)

iv. /= (Divide and Assign):
This operator divides a variable by a value and assigns the result back to that variable.
Example:
x = 20
x /= 5  # Equivalent to x = x / 5
print(x)

v. %= (Modulus and Assign):
This operator calculates the modulus (remainder) of a variable divided by a value and assigns the result back to that variable.
Example:
x = 5
y = 2
print(x%y)

x = 10
x %= 3  # Equivalent to x = x % 3
print(x)

Example: Updating Your Savings
Imagine you want to keep track of your savings and update it every time you spend money.

# Initial savings
savings = 2000

# You spend 500, so subtract that from your savings

savings -= 500  # This updates the savings in one step
print(f"Savings after expenses: ${savings}")  # Output: $1500

# You receive a bonus of 300, so add that to your savings
savings += 300  # This updates the savings in one step
print(f"Savings after bonus: ${savings}")

OUTPUT
Savings after expenses: $1500
Savings after bonus: $1800


5. IDENTITY OPERATORS
Used to check if two variables refer to the same object in memory. This concept is essential when you want to know if two variables point to the same place in memory, especially when dealing with mutable objects like lists.

List of Operators:
i. is:
This operator returns True if two variables point to the same object in memory.
Example:
# Creating a basket of fruits
basket1 = ["apple", "banana", "cherry"]
basket2 = basket1  # basket2 refers to the same basket as basket1
basket3 = ["apple", "banana", "cherry"]  # basket3 is a different basket

print(basket1 is basket2)  # Output: True  (Same basket)
print(basket1 is basket3)  # Output: False (Different baskets)

OUTPUT
True
False

ii. is not:
This operator returns True if two variables do not point to the same object in memory.
Example:
print(basket1 is not basket2)  # Output: False (Same basket)
print(basket1 is not basket3)  # Output: True  (Different baskets)

OUTPUT
False
True

Example: Comparing Baskets of Fruits

Imagine you have two baskets:

Basket A contains three fruits: an apple, a banana, and a cherry.
Basket B is another basket that you have filled with the same types of fruits: an apple, a banana, and a cherry.
While both baskets have the same contents, they are different physical baskets. If you check whether Basket A and Basket B are the same basket, you would say they are not the same, even though they contain identical fruits.

In Python terms:
# Two lists representing two baskets of fruits
basket_a = ["apple", "banana", "cherry"]
basket_b = ["apple", "banana", "cherry"]  # A different basket with the same fruits
basket_c = basket_a  # basket_c points to the same basket as basket_a

# Comparing identity
print(basket_a is basket_b)  # Output: False (Different baskets)
print(basket_a is basket_c)  # Output: True  (Same basket)

OUTPUT
False
True


6. MEMBERSHIP OPERATORS
Used to check if a value is present in a sequence, such as a list, string, or tuple. They are useful for determining whether a specific item exists in a collection.

List of Operators:
i. in:
This operator returns True if a value is found in a sequence.
Example:
# Say you have a list of expense categories
categories = ["rent", "groceries", "transportation"]

# Check if 'groceries' is "in" the list
print("groceries" in categories)  # Output: True

OUTPUT
True

ii. not in:
This operator returns True if a value "is not" found in a sequence.
Example:
# Check if 'utilities' is not in the list
print("utilities" not in categories)

OUTPUT
True

Example: Checking Attendance in a Class

Imagine you are a teacher taking attendance for your class. You have a list of students enrolled in the course, and you want to check if a specific student is present.

You have the following students in your class: Alisha, Ola, Charlie, and Remi.
In Python terms, you can represent this situation like this:

# List of students in the class
students = ["Alisha", "Blessing", "Charlie", "Remi"]

# As usual, kinldy ignore the strange word `if` for now.
# Check if 'Ola' is in the list of students
if "Ola" in students:
    print("Ola is present in the class.")  # This message will be printed
else:
    print("not in class")

# Check if 'Saed' is in the list of students
if "Saed" not in students:
    print("Saed is not enrolled in this class.")  # This message will be printed

OUTPUT
not in class
Saed is not enrolled in this class.

Link to Python Operators: https://colab.research.google.com/drive/1VBfQPX1JiG035NzOgXpY9nev9u7THtP_#scrollTo=979223ee

These operators are the building blocks that enable you to carry out various tasks in Python, from mathematical operations to logical comparisons, and even manipulating binary data. By mastering these operators, you'll be able to write more efficient and powerful code. Below is the precedence of operators in Python:

Python Operartor Precedence
Highest to lowest
i. Exponentiation (**)
ii. Unary positive, unary negative, bitwise negation (+X, -X, ~X)
iii. Addition, Subtraction (+, -)
iv. Left-shift, right-shift (<<, >>)
v. Bitwise AND (&)
vi. Bitwise XOR (^)
vii. Bitwise OR (|)
viii. Comparison, Identity (==, !=, <, <=, >, >=, is, is not)
ix. Boolean NOT (not)
x. Boolean AND (and)
xi. Boolean OR (or)


IF ELIF ELSE STATEMENT IN PYTHON
This video provides a comprehensive overview of key programming concepts in Python, focusing on conditional statements and their execution. It begins with an introduction to the different units of a CPU and transitions into understanding the structure and use of conditional statments like if, else, and elif. You'll learn about the importance of indentation in Python, explore how to execute conditional blocks effectively, and dive into nested conditional statements to handle complex decision-making scenarios.

Link to the If Elif Else Video: https://www.youtube.com/watch?v=PqFKRqpHrjw


"FOR" & "WHILE" LOOPS
This video dives into loops in Python, teaching you how to use for and while looops to repeat code efficiently. You'll also explore creating nested loops and managing loop behavior with break and continue statements.

Exercise:
Write a Python script that takes a list of numbers and prints the largest and the smallest numbers in the list.

# Solution
# Accept list of numbers from the user and split by spaces
num_lists = input("Enter numbers separated by spaces: ").split(' ')

# Convert the splitted numbers into a list and cast the result into an integer
num_list = []
for num in num_lists:
    num_list.append(int(num))

# Initialize variables to store the largest and smallest numbers
largest = num_list[-1]
smallest = num_list[-1]

# Iterate over the list of numbers, comparing for the largest and the smallest
for num in num_list:
    if num > largest:
        largest = num
    if num < smallest:
        smallest = num

print(num_list)
print(f"The largest is {largest}")
print(f"The smallest is {smallest}")

Link to the Video tutorial: https://www.youtube.com/watch?v=kYs_V4mRJgk


CONTROL FLOW STRUCTURES IN PYTHON
Control flow structures are essential in programming as they allow us to control the sequence of operation within a program. In Python, control flow tools include conditionals, loop, and control statements that allow you to decide what to execute and when.

1. Conditionals (if, elif, else)
Conditionals are used to execute certain blocks of code based on whether a condition is true or false. This is similar to how we make decisions every day: if itâ€™s raining, you take an umbrella; if itâ€™s not, you donâ€™t.

- if: Executes a block of code if the given condition evaluates to True.
- elif: Stands for "else if" and is used to check another condition if the previous one was False.
- else: Executes a block of code when all previous conditions are False
Example: Letâ€™s imagine you're preparing to go out in Lagos during the rainy season. You decide what to do based on the weather condition.

weather = "sunny"

if weather == "rainy":
    print("Take an umbrella!")  # This prints if the weather is rainy.
elif weather == "cloudy":
    print("Take a jacket.")  # This runs if the weather is cloudy.
else:
    print("You don't need anything special.")  # This runs if the weather is neither rainy nor cloudy.

OUTPUT:
You don't need anything special.

#lets check if based on the age of Bella she is eligible to vote
age = 34

if age > 30:
    print('Eligible')
else:
    print('Underage')

OUTPUT:
Eligible

#An even better way to write the above
#This is known as ternary operators

message = 'Eligible' if age>30 else 'Not Eligible'
print(message)

OUTPUT:
Eligible

Ternary Operators: A Concise Conditional Expression

A ternary operator, also known as a conditional operator, is a concise way to express a simple if-else condition in a single line of code. It's a shorthand for a basic if-else statement. Syntax:

condition ? expression1 : expression2

How it works:

Condition: The condition is evaluated.
Expression 1: If the condition is true, this expression is evaluated and its result is returned.
Expression 2: If the condition is false, this expression is evaluated and its result is returned.

#these are useful when you have a series of conditions to check and different actions to take based on those conditions

age = 16
country = 'Nigeria'

if age >= 18:
    if country == 'Nigeria':
        print('You can proceed to vote')
    else:
        print('You are up to age but not a citizen of Nigeria.')
else:
    print('You are not of age to vote')

OUTPUT:
You are not of age to vote

---------------------------------
'''
Another example:

The idea here is that for a particular grade, we want to check if it falls within a standard range and tehn print out the grades accordingly
if the grade received is between 65 and 100 then we proceed to finding what grade suits the student best
if however, the grade entered is above 100,the corresponding output is displayed

#Note that ''' ''' are used to denote multiline comments
'''

grade = 20

if grade >=65 and grade <=100:
    print('Bella got a passing grrade of:', end = ' ')

    if grade >= 90:
        print('A')
    elif grade >= 80:
        print('B')
    elif grade >= 70:
        print('C')
    elif grade >=65:
        print('D')
elif grade > 100:
    print('Invalid input')
else:
    print('Failing grade')

OUTPUT:
Failing grade

2. Loops
Loops are used to repeat a block of code multiple times. In Python, there are two types of loops: for loops and while loops.

A for loop is used to iterate over a sequence (like a list, string, or range of numbers). It is useful when you know in advance how many times you want to loop.

Example: Imagine youâ€™re distributing handouts to students in a Nigerian university class

students = ["Bola", "Ahmed", "Uche", "Tunde"]

for student in students:
    print(f"Here is your handout, {student}!")

Here is your handout, Bola!
Here is your handout, Ahmed!
Here is your handout, Uche!
Here is your handout, Tunde!

Here, the for loop goes through each name in the students list and distributes handouts.

integers = [1,2,3,4,5,6,7]

#where num is a temporary variable
#for each number in the integers list

for num in integers:
    print(num)

1
2
3
4
5
6
7

-----------------------------------
#adding the integers
integers = [1,2,3,4,5,6,7]
for num in integers:
    print(num+num)

2
4
6
8
10
12
14

with dictionaries

ice_cream ={'name': 'Cocoa', "weekly intake": 5, 'fav ice cream': ['MCC', 'Chocolate']}

'''
when iterating over a dictionary we need to specify what we want to pull from the dictionary
that is, whether we're extracting the keys or values hence we have `ice_cream.values()`
'''

for cream in ice_cream.values():
    print(cream)

Cocoa
5
['MCC', 'Chocolate']

---------------------------------
#this extracts the key-value pair itself
for key, value in ice_cream.items():
    print(key, '->', value)

name -> Cocoa
weekly intake -> 5
fav ice cream -> ['MCC', 'Chocolate']

------------------------------------
with tuples

tup = (10,20,30)

for tp in tup:
    print(tp)
print('Finish')

10
20
30
Finish

--------------------------------------
tup = (1,2,3,4,5)
prod =1

for item in tup:
    prod *= item
print('Product = {}'.format(prod))

Product = 120

-------------------------------------
using ranges

#iterating over a range where 1 = start point, 10 = end point, 2 = increments

for count in range(1,10,2):
    print('The count is: ', count)
print('Done with the loop!')

The count is:  1
The count is:  3
The count is:  5
The count is:  7
The count is:  9
Done with the loop!

-------------------------------------
with lists

my_list = [10,20,30,40,60]

for tp in range(len(my_list)):
    print(my_list[tp])
    print(tp)
    print()

10
0

20
1

30
2

40
3

60
4

------------------------------------
print('Dict iteration')

dict = {}
dict['num 1'] = 'Bella'
dict['num 2'] = 'Jane'

for key in dict.keys():
    print(key)

Dict iteration
num 1
num 2

--------------------------------------
Nested for loops - a for loop within a for loop

flavors = ['vanilla', 'choco', 'cookie dough']

toppings = ['marsh', 'oreo', 'hot fudge']

for one in flavors:
    for two in toppings:
        print(one, 'topped with', two)


for one in flavors:
    for two in toppings:
        print(one, 'topped with', two)
vanilla topped with marsh
vanilla topped with oreo
vanilla topped with hot fudge
choco topped with marsh
choco topped with oreo
choco topped with hot fudge
cookie dough topped with marsh
cookie dough topped with oreo
cookie dough topped with hot fudge

--------------------------------------
2.2 While loops

A while loop keeps executing as long as a condition is True. Itâ€™s like waiting for fuel to be available in a filling station during scarcityâ€”if the station remains empty, you keep waiting.

Example:

Letâ€™s say you keep checking your phone for mobile data credit until it gets credited:

data_balance = 0

while data_balance == 0:
    print("Still waiting for data to be credited...")
    # After a while, data is credited
    data_balance = 100

print("You now have data!")

Still waiting for data to be credited...
You now have data!

---------------------------------------
This loop continues until you receive data credit.

number = 0
while number < 5:
    print(number)
    number = number + 1 #a counter


number = 0
while number < 5:
    print(number)
    number = number + 1 #a counter
0
1
2
3
4

--------------------------------------
number = 0
while number < 5:
    number = number + 1
    print(number)

1
2
3
4
5

Did you notice the difference between both code blocks above.

--------------------------------------
count = 0
while count<3:
    print('The count is: ', count)
    count = count+1
print('Good bye! count is: ', count)

The count is:  0
The count is:  1
The count is:  2
Good bye! count is:  3

-----------------------------------
tup = (1,2,3,4,5)

prod = 1
index = 0

while index < len(tup):
    prod *= tup[index]   #multiply the current value of prod by tup[index] #'index' is used as a variable to index the values
    index +=1
print('Product = {}'.format(prod))

Product = 120

--------------------------------------
3. Control Statements (break, continue, pass)

Control statements allow you to manipulate the flow of loops by either breaking out of them, skipping iterations, or doing nothing in a particular case.

3.1 Break
The break statement is used to exit a loop entirely. Itâ€™s like stopping a task midway when itâ€™s no longer necessary.

Example:

You are buying gala on the Third Mainland Bridge, but you stop buying once youâ€™ve bought three.

for gala in range(10):
    if gala == 5:
        break  # Stop buying after 3
    print(f"Bought gala number {gala + 1}")
print('Stop buying gala')

Bought gala number 1
Bought gala number 2
Bought gala number 3
Bought gala number 4
Bought gala number 5
Stop buying gala

number = 0

while number < 5:
    print(number)
    if number == 3:
        break  #stops the code execution at 3
    number = number + 1

0
1
2
3

------------------------------------
number = 0

while number < 5:
    print(number)
    if number == 6:
        break
    number = number + 1
else:
    print('No longer < 5')


number = 0

while number < 5:
    print(number)
    if number == 6:
        break
    number = number + 1
else:
    print('No longer < 5')
0
1
2
3
4
No longer < 5

---------------------------------------
3.2 Continue

continue is used to skip the current iteration of a loop and continue with the next one. Think of it as skipping some tasks in a list but not abandoning the whole list.

Example: Imagine you are going through a list of students and want to skip over anyone named "Uche" when printing names.

students = ["Bola", "Uche", "Ada", "Emeka"]

for student in students:
    if student == "Uche":
        continue  # Skip Uche
    print(f"Processing {student}'s record.")

Processing Bola's record.
Processing Ada's record.
Processing Emeka's record.

In this case, the loop skips over "Uche" and continues processing the other students.

number = 0

while number < 5:
    number = number + 1
    if number == 3:
        continue
    print(number)
else:
    print('No longer <5')

1
2
4
5
No longer <5

--------------------------------------
3.3 Pass
pass is used when you want to skip or ignore certain parts of your code without causing any errors. Itâ€™s like saying "I donâ€™t want to do anything here right now, but Iâ€™ll come back to it later."

Example: Imagine you are listing names and donâ€™t want to perform any action for a particular person, but you donâ€™t want the program to break:

names = ["Bola", "Uche", "Ada", "Emeka"]

for name in names:
    if name == "Uche":
        pass  # Do nothing for Uche
    else:
        print(f"Processing {name}'s record.")

Processing Bola's record.
Processing Ada's record.
Processing Emeka's record.

In this case, when the loop encounters "Uche," it simply does nothing and moves to the next name in the list. The pass statement helps to keep the code running smoothly.

---------------------------------------
3.4 Match
The match statement is a new addition to Python, it allows you to match a value against several patterns and execute code based on the matching pattern.

In simple terms, it helps you check a value and choose what to do based on that value. It's like asking a series of "yes or no" questions until you find the right answer.

Explanation:

match: This evaluates the value of an expression and compares it to several case patterns. In simple terms it is used to compare one value with several options to see which one it matches.
case: Each case checks whether the value matches a specific pattern. If a match is found, the code block is executed. Thus: If the value fits a case, the code inside that case will run
Example: Imagine you are grading students in a Nigerian university based on their scores:

grade = "B"

match grade:
    case "A":
        print("Excellent! You scored an A.")
    case "B":
        print("Good job! You scored a B.")
    case "C":
        print("You scored a C. Try to improve.")
    case _:
        print("Failed. Better luck next time.")

Good job! You scored a B.

Control flow structures are essential for making decisions in Python programming. They help you implement logic, repeat actions, and manage how your program runs. By understanding these structures, you'll build a strong foundation for creating more complex programs that solve everyday problems.

-----------------------------------------
Task
Create a quiz game with multiple-choice questions, branching based on user input and calculating scores.

# 1st attempt - testing a theory

Question = 'What has long neck and likes to eat leaves'
print(Question)

Answer = str(input())

if Answer == 'Giraffe':
    point = 1
    print('Correct answer, you have: ', point, 'point')
else:
    print('Wrong answer, you have ', 0, 'points')

What has long neck and likes to eat leaves
Chicken
Wrong answer, you have  0 points

----------------------------------------
#2nd attempt - expanding the theory
#this worked but not as much

#Testing 1
Questions = ['What has long neck and likes to eat leaves?', 'What animal can fly?', 'What is a group of lions called?']

for question in Questions:
    print(question)
    Answer = str(input())

    if Answer == 'Giraffe':
        point = 1
        print('Correct answer, you have: ', point, 'point')

    elif Answer == 'Bird':
        point = point+1
        print('Correct! You have ', point, 'points')

    elif Answer == 'Pride':
        point = point+1
        print('Correct! Total points: ', point)

    else:
        print('Wrong answer, you have ', 0, 'points')

What has long neck and likes to eat leaves?
Giraffe
Correct answer, you have:  1 point
What animal can fly?
Bird
Correct! You have  2 points
What is a group of lions called?
Pride
Correct! Total points:  3

-------------------------------------
#2nd attempt

#Testing 2 - this iteration didn't work as expected

Questions = ['What has long neck and likes to eat leaves?', 'What animal can fly?', 'What is a group of lions called?']

for question in Questions:
    print(question)
    Answer = str(input())

    if Answer == 'Giraffe':
        point = 1
        print('Correct answer, you have: ', point, 'point')

    elif Answer == 'Bird':
        point = point+1
        print('Correct! You have ', point, 'points')

    elif Answer == 'Pride':
        point = point+1
        print('Correct! Total points: ', point)

    else:
        print('Wrong answer, you have ', 0, 'points')

What has long neck and likes to eat leaves?
Rabbit
Wrong answer, you have  0 points
What animal can fly?
Dove
Wrong answer, you have  0 points
What is a group of lions called?
Pride
Correct! Total points:  3

----------------------------------------
#3rd attempt

# Though a bit longer, it worked
# Intialized the score variable outside the for loop
# Calculated the total score for each question and printed the total score outside the for loop


Questions = ['What has long neck and likes to eat leaves?', 'What animal can fly?', 'What is a group of lions called?']

score = 0

for question in Questions:
    print(f'\n{question}')
    Answer = str(input())

    if Answer == 'Giraffe':
        point = 1
        score += 1
        print('\nCorrect! ', point, 'point')

    elif Answer == 'Bird':
        point = 1
        score += 1
        print('\nCorrect! ', point, 'points')

    elif Answer == 'Pride':
        point = 1
        score += 1
        print('\nCorrect! Total point ', point)

    else:
        print('\nWrong answer!')
print(f'\n\nTotal points = {score}')

What has long neck and likes to eat leaves?
Rabbit

Wrong answer!

What animal can fly?
Dove

Wrong answer!

What is a group of lions called?
School

Wrong answer!


Total points = 0

-------------------------------------
Questions = ['What has long neck and likes to eat leaves?', 'What animal can fly?', 'What is a group of lions called?']

score = 0

for question in Questions:
    print(f'\n{question}')
    Answer = str(input())

    if Answer == 'Giraffe':
        point = 1
        score += 1
        print('\nCorrect! ', point, 'point')

    elif Answer == 'Bird':
        point = 1
        score += 1
        print('\nCorrect! ', point, 'points')

    elif Answer == 'Pride':
        point = 1
        score += 1
        print('\nCorrect! Total point ', point)

    else:
        print('\nWrong answer!')
print(f'\n\nTotal points = {score}')

What has long neck and likes to eat leaves?
Giraffe

Correct!  1 point

What animal can fly?
Bird

Correct!  1 points

What is a group of lions called?
School

Wrong answer!


Total points = 2


PYTHON FUNCTIONS AND MODULES
When you start working with Python, you might write all your code in one file. However, as your programs become larger, managing everything in one place can get messy. This is where modules come in! Modules help you organize and reuse your code, making your programs more efficient and easy to manage. And functions are reusable blocks of code that carry out a specific task.

Link to the file: https://colab.research.google.com/drive/1uRourfPWhpfVdAU8JBseckvzK96OozNP#scrollTo=0b62078a


PYTHON FUNCTIONS
Functions are reusable blocks of code that carry out a specific task.

Why Use Functions?
Reusability: Write code once, use it many times.
Readability: Organizes code into smaller chunks that are easier to understand.
Debugging: Easier to troubleshoot and fix bugs when code is broken into functions.
Modularity: Makes it easier to divide and conquer problems.
Example

A function to calculate the area of a Rectangle.

Weâ€™ll define a function called calculate_area that takes two parameters: width and height.

def calculate_area(width, height):
  area = width * height
  return area

What just happened?

Function Definition: We created the calculate_area function that accepts two parameters: width and height. Inside the function, we multiply these two values to get the area, then return the result.

Function Call: When we call the function using calculate_area(5, 10), it calculates 5 * 10 and returns the result as seen below:

calculate_area(5,10)

50

It doesn't stop there, you can try it out with other values.

print(calculate_area(7, 3))
print(calculate_area(6, 8))

21
48

How to Define a Function in Python.

Basic Syntax

In Python, a function is defined using the def keyword followed by the function name and parentheses ().

def function_name():
    # Block of code inside the function
    print("Hello, world!")

[ ]
def function_name():
    # Block of code inside the function
    print("Hello, world!")
Step-by-Step Breakdown
def keyword: This tells Python that you're defining a function.

function_name: This is the name of your function. It should be meaningful and describe what the function does.

Parentheses (): They are required even if the function doesn't take any arguments.

Colon : : This indicates the start of the functionâ€™s body.

Indentation: Python uses indentation (usually 4 spaces) to mark the code that belongs to the function.

Calling a Function
To use the function youâ€™ve defined, just type the function name followed by parentheses:

function_name()

Hello, world!

Functions with Parameters
You can make your functions more flexible by passing parameters (inputs) to them. Parameters allow you to provide information that the function can use when it runs.

Syntax with Parameters:

def greet(name):
    print("Hello,", name)

# calling the function
greet("Alice")
greet("Hannah")

Hello, Alice
Hello, Hannah

In this example, "name" is the parameter. When calling greet(), you provide the actual value (like "Alice" or "Bob") known as an argument.

Functions with Return Values
Sometimes, you want a function to calculate or process something and return the result. You can use the return statement to send back a value.

Syntax with Return Value:

# Define functons
def add_numbers(a, b):
    return a + b

# call functions
result = add_numbers(3, 5)
print(result)

8

Here, add_numbers takes two arguments a and b, adds them together, and returns the result. The returned value is then stored in the result variable.

Types of parameters
Positional parameters
Default Parameters
Keyword Parameters
Positional Parameters:
When you define a function in Python, you can specify parameters that the function expects to receive. These are called positional parameters. The key thing about positional parameters is that the arguments you pass to the function must be in the same order as the parameters are defined.

Example:

def greet(first_name, last_name):
    print("Hello,", first_name, " ", last_name)

greet("Igboke", "Hannah")

Hello, Igboke   Hannah

Explanation:

The function greet takes two parameters: first_name and last_name.

When you call greet("Bill", "Clinton"), Python matches the first argument ("Bill") to the first parameter (first_name), and the second argument ("Clinton") to the second parameter (last_name).
If you switch the arguments, the meaning changes:

greet("Clinton", "Bill")

Hello, Clinton   Bill

In summary:

Positional parameters must be passed in the correct order.
Default Parameters
You can assign default values to parameters in Python functions. This means that if you don't provide a value for that parameter when calling the function, Python will use the default value.

Example:

def greet(first_name, last_name="Smith"):
    print(f"Hello, {first_name} {last_name}!")

greet("Alice")
greet("Alice", "Johnson")

Hello, Alice Smith!
Hello, Alice Johnson!

Explanation:
The function greet has two parameters: first_name and last_name. The last_name parameter has a default value of "Smith".
If you don't provide a value for last_name, the function uses "Smith" as the last name.
If you provide both first_name and last_name, the function uses your provided values.
In summary:

Default parameters are useful when you want to make some parameters optional.

Keyword Parameters
Keyword parameters allow you to specify which parameter gets which value, regardless of the order of the parameters. You do this by naming the parameter in the function call.

Example:

def greet(first_name, last_name):
    print(f"Hello, {first_name} {last_name}!")

greet(last_name="Doe", first_name="John")

Hello, John Doe!

Explanation:
When calling greet, you use first_name="John" and last_name="Doe", so Python knows exactly which argument goes with which parameter.
The order doesn't matter when using keyword arguments.
You can combine positional and keyword arguments:

greet("John", last_name="Doe")

Hello, John Doe!

Putting It All Together:
You can mix positional parameters, default parameters, and keyword parameters in one function. Hereâ€™s an example:

Example:

def describe_person(name, age=25, city="Brazil"):
    print(f"{name} is {age} years old and lives in {city}.")

describe_person("Alice", 50, "Nigeria")
describe_person("Bob", 30)
describe_person(name="Charlie", city="Paris")

Explanation:
name is a positional parameter.
age and city have default values.
You can use keyword parameters to pass city="Paris" without worrying about the order.
Difference between using a return and print in a function call.

def add(x,y):
    return x+y

def add_2(x,y):
    print(x+y)

result = add(3,5)
print(result)

8

result2 = add_2(3,5)
print(result2)


result2 = add_2(3,5)
print(result2)

8
None

result2 = add_2(2,2)

print(result2)

4
None

This results in 4 because the print statement in the function prints it but does not return the result in order to assign it to a new variable. This gives us 'None' because no value is saved in it.

def even_odd(var):
    if var % 2 == 0:
        return 'Even'
    else:
        return 'Odd'

even_odd(5678034651700975357)

Odd

print('Enter a number...')
user_input = int(input())

print('Number is ', even_odd(user_input))

Enter a number...
543
Number is  Odd

Think of return as you desiring to be able to use the results of your function code in variables in every other place in the code.

But wait, we just tried something new.....

User input handling or input processing!!

Here's a breakdown of the specific actions in the code:

Prompting the User: The print('Enter a number...') line is used to prompt the user, which is a common step in user interaction within console applications.

Getting User Input: The input() function is called to collect input from the user. In Python, input() reads input as a string from the console.

Type Conversion (also called Type Casting): The code converts the input string to an integer with int(input()). This is necessary when you need the input to be a specific data type, like an integer, instead of the default string type returned by input().

Writing a program, to multiply a number with 10 if the given number is odd:

def check_even_odd(num):
    if num % 2 != 0:
        num*=10
    else:
        num
    return num

print('Enter a number...')
user_input = int(input())

print(check_even_odd(user_input))

Enter a number...
70
70

More on function definition and calling a function.

def my_first_function():
    '''
    Return an object that produces a sequence of integers from start (inclusive)
    to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.
    start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.
    These are exactly the valid indices for a list of 4 elements.
    When step is given, it specifies the increment (or decrement).
    '''
    print('Hello Xterns')

Notice the in line comment made within the function call. Defining an in-line comment like this helps to document what the function is meant to do.

my_first_function()

Hello Xterns

#running the line below retrieves the descriptive text explaining what the code is supposed to do.

print(my_first_function.__doc__)

#running the line below retrieves the descriptive text explaining what the code is supposed to do.

print(my_first_function.__doc__)

__doc__ is an attribute that provides a way to attach documentation to code objects like: functions, classes and modules. It is used to promote clean, well-documented and maintainable code in python

Example:

#retrive the documentation for the range function
print(range.__doc__)

#it feels like you are using the help function

range(stop) -> range object
range(start, stop[, step]) -> range object

Return an object that produces a sequence of integers from start (inclusive)
to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.
start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.
These are exactly the valid indices for a list of 4 elements.
When step is given, it specifies the increment (or decrement).

#Write a function to take a number and square it

def square(num):
    print('The square of {} is {}'.format(num, num**2))

square(6)

The square of 6 is 36

Multiple returns

def add_sub(a,b):
    add = a+b
    if a> b:
        sub = a-b
    else:
        sub = b-a
    return add, sub

user_input = int(input())
user_input2 = int(input())
print(add_sub(user_input, user_input2))

5
45
(50, 40)

print(enumerate.__doc__)

Return an enumerate object.

  iterable
    an object supporting iteration

The enumerate object yields pairs containing a count (from start, which
defaults to zero) and a value yielded by the iterable argument.

enumerate is useful for obtaining an indexed list:
    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...


F. MODULES
When you start working with Python, you might write all your code in one file. However, as your programs become larger, managing everything in one place can get messy. This is where modules come in! Modules help you organize and reuse your code, making your programs more efficient and easy to manage.

A module in Python is simply a file that contains Python code, such as functions, variables, and classes, which can be used in other Python programs. This helps to break down large programs into smaller, manageable, and reusable pieces.

Why Use Modules?:

Organize Code: Modules help keep your code clean and structured. You can split your program into multiple files (modules), each handling specific tasks.
Reuse Code: Once a module is created, you can reuse it in any number of programs, avoiding the need to rewrite the same code over and over.
Maintainability: If your code is separated into modules, fixing bugs or adding features becomes much easier since each module focuses on a specific functionality.
How to Use a Module in Python

Python has many built-in modules that you can use right away, and you can also create your own. To use a module in your program, you need to import it. Python provides the import statement for this purpose.
First, we will try to create our own moduleðŸ‘‡

Creating your own module
Method 1

You can use visual studio code for this:

Create a python file called "Calc"
In it define the functions you want to be able to use - in this case add, sub, divide and multiplication
In a new python file import this Calc module and then run it
Method 2

You can create your own module by simply writing some Python code in a .py file and saving it. Later on, we'll create a module called mymodule.py

#using method 1
#creating the Calc functions

def add(a,b):
    return a+b

def sub(a,b):
    return a-b

def multiply(a,b):
    return a*b

def divide(a,b):
    return a/b

#importing the Calc module

import Calc

c = Calc.add(4,7)

#OR

from Calc import add
c = add(4,7)

#using method 2

#mymodule.py:
def greet(name):
    return f"Hello, {name}!"

def add(a, b):
    return a + b

Now, you can import and use this module in any other Python file.

import mymodule

#Using functions from mymodule
print(mymodule.greet("Alice"))  # Output: Hello, Alice!
print(mymodule.add(10, 5))      # Output: 15

Common python modules
Now, we can talk about using built-in python modules

1. os module
This provides numerous tools to deal with filenmaes, paths and directories

import os
import os.path
print(os.name)

#where nt is used to represent windows operating system
#'posix' for example indictes a Unix-like operating system

nt

#to get the current working directory

print(os.getcwd())

C:\Users\USER

#printing the absolute path

#print(os.path.abspath('.'))

#returns a list of all the directories in a folder
os.listdir('.')

['.azuredatastudio',
 '.cache',
 '.cargo',
 '.conda',
 '.condarc',
 '.continuum',
 '.dotnet',
 '.env_prefect',
 '.gitconfig',
 '.ipynb_checkpoints',
 '.ipython',
 '.jupyter',
 '.matplotlib',
 '.prefect',
 '.rustup',
 '.spyder-py3',
 '.ssh',
 '.streamlit',
 '.templateengine',
 '...']

#to see a list of the operating system's environment variables

os.environ

environ{'ALLUSERSPROFILE': 'C:\\ProgramData',
        'APPDATA': 'C:\\Users\\USER\\AppData\\Roaming',
        'COMMONPROGRAMFILES': 'C:\\Program Files\\Common Files',
        'COMMONPROGRAMFILES(X86)': 'C:\\Program Files (x86)\\Common Files',
        'COMMONPROGRAMW6432': 'C:\\Program Files\\Common Files',
        'COMPUTERNAME': 'HANNAH',
        'COMSPEC': 'C:\\WINDOWS\\system32\\cmd.exe',
        'CONDA_DEFAULT_ENV': 'base',
        'CONDA_EXE': 'C:\\Users\\USER\\anaconda3\\Scripts\\conda.exe',
        'CONDA_PROMPT_MODIFIER': '(base) ',
        'CONDA_PYTHON_EXE': 'C:\\Users\\USER\\anaconda3\\python.exe',
        'CONDA_SHLVL': '1',
        'DRIVERDATA': 'C:\\Windows\\System32\\Drivers\\DriverData',
        'FPS_BROWSER_APP_PROFILE_STRING': 'Internet Explorer',
        'FPS_BROWSER_USER_PROFILE_STRING': 'Default',
        'HOMEDRIVE': 'C:', ...}

2. platform module
Provides functions to access information about the system where my python code is running

import platform

print(platform.version())
print(platform.system())
print(platform.release())
print(platform.platform())
print(platform.win32_ver())

10.0.19045
Windows
10
Windows-10-10.0.19045-SP0
('10', '10.0.19045', 'SP0', 'Multiprocessor Free')

#os.path provides methods to extract info about paths and filenames

import os
import os.path
print(os.path.isdir(os.getcwd()))  #retrieves the current directory and checks if the dir exists
print(os.path.isfile('RAG app.ipynb')) #checks if the file exists
print(os.path.exists(os.getcwd())) #retrives the current directory and checks if it exists
print(os.path.getsize('RAG app.ipynb')) #retrieves the size of the file without opening it

True
True
True
64581

os.mkdir('name of dir') #creates a new dir inside the current directory
os.rmdir('name of dir') #removes dir from the current directory

3. datetime module
Whenever you need to manipulate dates or times, you need to import the datetime function.

from datetime import date, time, datetime

today = date.today()

t_now = datetime.time(datetime.now())

print(t_now)

18:56:24.718334

help(datetime)

#this retrives the documentation associated with a module

from datetime import date
from datetime import time
from datetime import datetime

def main():
    today = datetime.now()

    wd = datetime.weekday(today)

    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
    print('Today is day number %d' % wd)

    print('And today is: ', days[wd])

if __name__ == "__main__":
    main()

Today is day number 2
And today is:  Wednesday

Formating Date and Time Output with Strftime()

from datetime import datetime
now = datetime.now()
print(now)

2024-05-02 05:17:00.099870

# %c = local date and time

print(now.strftime('%c'))

Thu May  2 05:17:00 2024

# %x = local date

print(now.strftime('%x'))

05/02/24

# %X = local time
print(now.strftime("%X"))

05:17:00

Time formatting
%I - 12-hour
%H - 24-hour
%M - Minute
%S - second
%p - Local's AM/PM

print(now.strftime('%I:%M:%S:%p'))
print(now.strftime('%H:%M'))
print(now.strftime('%I:%M'))

05:17:00:AM
05:17
05:17

Using timedelta objects
This is used to estimate time for both the future and the past. It is not for printing out the date and time but to calulate a time in the past or future.

from datetime import timedelta
from datetime import datetime

#constructing a basic timedelta
my_timedelta = timedelta(days=10000, hours=8, minutes=15)
print(my_timedelta)

#printing today's date
print(datetime.now())

#print the date, 10000 days from now
print('\n\n10,000 days from now, the date would be: ' + str(datetime.now() + timedelta(days=10000)))

10000 days, 8:15:00
2024-05-02 05:28:07.118859


10,000 days from now, the date would be: 2051-09-18 05:28:07.118859

# dir is an inbuilt python function that returns a list of all the attributes and methods available in a module you specify
dir(datetime)

4. maths module
Provides access to the mathematical functions defined by the c standard

import math

dir(math)

['__doc__',
 '__loader__',
 '__name__',
 '__package__',
 '__spec__',
 'acos',
 'acosh',
 'asin',
 'asinh',
 'atan',
 'atan2',...]

#help is used to get more information on the methods associated with a module

help(math)

5. Random module
Used when we want the computer to pick a number in a given range.

import random
from random import *
print(random())

0.03864626327970577

dir(random)

help(random)

# returns an integer between the numbers specified, the numbers are inclusive

import random
print(random.randint(3,7))

The uniform function
# returns a random floating point between the numbers specified, the numbers are inclusive

print(uniform(3,7))

6.809852053882518

The choice function
# it generates a random value from the sequence
# it used to choose a random element from a list


import random
my_list = ['NASA', 'Hannah', 7786, {'food': 'rice and beans'}]

print(random.choice(my_list))
print(choice(my_list))

NASA
7786

The Shuffle function
#used the shuffle the elements in a list in place so they are in random order

import random
print('Before shuffling: ', my_list)

Before shuffling:  ['NASA', 'Hannah', 7786, {'food': 'rice and beans'}]

According to the rules we are to shuffle before we include the list in a print statement

import random

shuffle(my_list)
print('\nAfter shuffling: ', my_list)

After shuffling:  [7786, {'food': 'rice and beans'}, 'Hannah', 'NASA']

The randrange function
#generates a randomly selected element from range(start, stop, step)

import random
for i in range(5):
    print(random.randrange(0, 101, 5))

5
85
100
65
55

The sample function
import random
c=list(range(0,20))
print(c)

#the sample function is used to return a list of unique elements choosen at random from the sequence
print(random.sample(c, 10))

[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[8, 18, 12, 10, 19, 6, 16, 14, 1, 0]

6. Webbrowser module
This module is used to provide an interface to display web-based documents.

import webbrowser
dir(webbrowser)

['BackgroundBrowser',
 'BaseBrowser',
 'Chrome',
 'Chromium',
 'Elinks',
 'Error',
 'Galeon',
 'GenericBrowser',
 'Grail',
 'Konqueror',
 'Mozilla',
 'Netscape',...]

help(webbrowser)

import webbrowser
google = input('Enter Your Google search:')
webbrowser.open_new_tab('http://www.google.com/search?btnG=1&q=%s' % google)

Enter Your Google search:Djpunjab.com
True

import webbrowser as wb
google = input('Enter google search: ')
wb.open_new_tab("http://www.google.com/search?q=%s" % google)

[ ]
import webbrowser as wb
google = input('Enter google search: ')
wb.open_new_tab("http://www.google.com/search?q=%s" % google)

Enter google search: Deep learning
True

7. Calendar module
Displays the calendar

dir(calendar)

help(calendar)

import calendar

year = 2027
month = 12

#displaying the calendar
print(calendar.month(year, month))

   December 2027
Mo Tu We Th Fr Sa Su
       1  2  3  4  5
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 22 23 24 25 26
27 28 29 30 31

#to display the calendar for the entire year
from calendar import *
year = 2030

print(calendar(year))

2030

      January                   February                   March
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
    1  2  3  4  5  6                   1  2  3                   1  2  3
 7  8  9 10 11 12 13       4  5  6  7  8  9 10       4  5  6  7  8  9 10
14 15 16 17 18 19 20      11 12 13 14 15 16 17      11 12 13 14 15 16 17
21 22 23 24 25 26 27      18 19 20 21 22 23 24      18 19 20 21 22 23 24
28 29 30 31               25 26 27 28               25 26 27 28 29 30 31

       April                      May                       June
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
 1  2  3  4  5  6  7             1  2  3  4  5                      1  2
 8  9 10 11 12 13 14       6  7  8  9 10 11 12       3  4  5  6  7  8  9
15 16 17 18 19 20 21      13 14 15 16 17 18 19      10 11 12 13 14 15 16
22 23 24 25 26 27 28      20 21 22 23 24 25 26      17 18 19 20 21 22 23
29 30                     27 28 29 30 31            24 25 26 27 28 29 30

        July                     August                  September
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
 1  2  3  4  5  6  7                1  2  3  4                         1
 8  9 10 11 12 13 14       5  6  7  8  9 10 11       2  3  4  5  6  7  8
15 16 17 18 19 20 21      12 13 14 15 16 17 18       9 10 11 12 13 14 15
22 23 24 25 26 27 28      19 20 21 22 23 24 25      16 17 18 19 20 21 22
29 30 31                  26 27 28 29 30 31         23 24 25 26 27 28 29
                                                    30

      October                   November                  December
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
    1  2  3  4  5  6                   1  2  3                         1
 7  8  9 10 11 12 13       4  5  6  7  8  9 10       2  3  4  5  6  7  8
14 15 16 17 18 19 20      11 12 13 14 15 16 17       9 10 11 12 13 14 15
21 22 23 24 25 26 27      18 19 20 21 22 23 24      16 17 18 19 20 21 22
28 29 30 31               25 26 27 28 29 30         23 24 25 26 27 28 29
                                                    30 31

#operation 1 - calendar(year, w, l, c)
#displays the year, width of characters, number of lines per week and column seperators

import calendar
print(calendar.calendar(2024, 3,1,6))

2024

          January                          February                          March
Mon Tue Wed Thu Fri Sat Sun      Mon Tue Wed Thu Fri Sat Sun      Mon Tue Wed Thu Fri Sat Sun
  1   2   3   4   5   6   7                    1   2   3   4                        1   2   3
  8   9  10  11  12  13  14        5   6   7   8   9  10  11        4   5   6   7   8   9  10
 15  16  17  18  19  20  21       12  13  14  15  16  17  18       11  12  13  14  15  16  17
 22  23  24  25  26  27  28       19  20  21  22  23  24  25       18  19  20  21  22  23  24
 29  30  31                       26  27  28  29                   25  26  27  28  29  30  31

           April                             May                              June
Mon Tue Wed Thu Fri Sat Sun      Mon Tue Wed Thu Fri Sat Sun      Mon Tue Wed Thu Fri Sat Sun
  1   2   3   4   5   6   7                1   2   3   4   5                            1   2
  8   9  10  11  12  13  14        6   7   8   9  10  11  12        3   4   5   6   7   8   9
 15  16  17  18  19  20  21       13  14  15  16  17  18  19       10  11  12  13  14  15  16
 22  23  24  25  26  27  28       20  21  22  23  24  25  26       17  18  19  20  21  22  23
 29  30                           27  28  29  30  31               24  25  26  27  28  29  30

            July                            August                         September
Mon Tue Wed Thu Fri Sat Sun      Mon Tue Wed Thu Fri Sat Sun      Mon Tue Wed Thu Fri Sat Sun
  1   2   3   4   5   6   7                    1   2   3   4                                1
  8   9  10  11  12  13  14        5   6   7   8   9  10  11        2   3   4   5   6   7   8
 15  16  17  18  19  20  21       12  13  14  15  16  17  18        9  10  11  12  13  14  15
 22  23  24  25  26  27  28       19  20  21  22  23  24  25       16  17  18  19  20  21  22
 29  30  31                       26  27  28  29  30  31           23  24  25  26  27  28  29
                                                                   30

          October                          November                         December
Mon Tue Wed Thu Fri Sat Sun      Mon Tue Wed Thu Fri Sat Sun      Mon Tue Wed Thu Fri Sat Sun
      1   2   3   4   5   6                        1   2   3                                1
  7   8   9  10  11  12  13        4   5   6   7   8   9  10        2   3   4   5   6   7   8
 14  15  16  17  18  19  20       11  12  13  14  15  16  17        9  10  11  12  13  14  15
 21  22  23  24  25  26  27       18  19  20  21  22  23  24       16  17  18  19  20  21  22
 28  29  30  31                   25  26  27  28  29  30           23  24  25  26  27  28  29
                                                                   30  31

#operation 2 - isleap()
calendar.isleap(2098)

False

#operation 3 - month(year, month, w, l)

import calendar
print(calendar.month(2034, 5, 3, 1))

 May 2034
Mon Tue Wed Thu Fri Sat Sun
  1   2   3   4   5   6   7
  8   9  10  11  12  13  14
 15  16  17  18  19  20  21
 22  23  24  25  26  27  28
 29  30  31

Sometimes, you donâ€™t want to import the entire module. Instead, you might want to import just a specific function or variable. You can do this by specifying the function or variable after the from keyword. Example:

from math import sqrt

Here, we import only the sqrt function from the math module. Now we can use sqrt() directly without needing to type math.sqrt().

Renaming a Module:

You can give a module or function a short alias to make it easier to work with, especially if the module name is long.

import math as m # rename the module to "m"

result = m.pi
print(result)

3.141592653589793

----------------------------------------
Task
An app that allows you check if a number is a prime number or armstrong.

The logic behind the prime number
Prime numbers are positive integers. It is divisible by only one and itself, every other number always returns a remainder. Also, 1 is not considered a prime number

Logic of armstrong number
It is a number that is the sum of its own digits(which has each been raised to the power of the number of digits)

153 is an armstrong number because 1^3 + 5^3 + 3^3 = 153

So to write the logic/function:

We need to be able to access the len of the integer value or the count of the number of integers
Next, we need to extract each digit and raise it the power of the count of the digits and sum them
When this is done, we now compare this number with the input
153 -> 153%10 = 15 rem 3

15 -> 15%10 = 1 rem 5

1 -> 1%10 = 0 rem 1

#attempt for the prime number
user_input = int(input())

def is_prime(num):
    if num<=1:
        return False

    #moving on
    for i in range(2, int(num**0.5)+1):  #range starts from 2 (inclusive) to the last number(exclusive)
        if num%i==0:  #this means it has a divisor
            return 'Not prime'
        return 'Prime'
print(is_prime(user_input))

531
Prime

check = int(len(str(1234)))
check

4

type(check)

int

#attempt for armstrong number
def is_armstrong(num):
    count_digits = int(len(str(num)))

    temp = num #creating a temp variable to avoid modifying the original input

    sum = 0

    while temp!=0:
        rem = temp%10
        temp = temp//10
        sum += rem ** count_digits

    if sum == num:
        return ('Armstrong!')

check = is_armstrong(1634)
print(check)

Armstrong!

#combining both functionalities

print('Enter "prime" or "armstrong" according to your need.')

user_input = str(input())

if user_input == 'prime':
    number = int(input('Enter a number '))

    def is_prime(num):
        if num<1:
            return('\nEnter a positive number!')
        elif num == 1:
            return('\n1 is not a prime number!')

        #moving on
        for i in range(2, int(num**0.5)+1):
            if num%i==0:
                return ('\n\nNot prime')
            else:
                return ('\n\nPrime number')
    print(is_prime(number))


elif user_input == 'armstrong':
    number = int(input('\nEnter a number '))

    def is_armstrong(num):
        count_digits = int(len(str(num)))

        temp = num
        sum = 0

        while temp!=0:
            rem = temp%10
            temp = temp//10
            sum += rem ** count_digits

        if sum == number:
            return ('\nArmstrong!')
        else:
            return ('\nNot armstrong!')
    print(is_armstrong(number))

else:
    print('\n\nEnter a valid instruction!')

goodbye_message = str(input('What do you have to say to me? '))

Enter "prime" or "armstrong" according to your need.
prime
Enter a number 33


Prime number
What do you have to say to me? Thank you.

----------------------------------------
Task
Building Simple Calculator by Using Functions

# This function adds two numbers
def add(x, y):
    return x + y

# This function subtracts two numbers
def subtract(x, y):
    return x - y

# This function multiplies two numbers
def multiply(x, y):
    return x * y

# This function divides two numbers
def divide(x, y):
    return x / y


print("Select operation.")
print("1.Add")
print("2.Subtract")
print("3.Multiply")
print("4.Divide")

while True:
    # take input from the user
    choice = input("Enter choice(1/2/3/4): ")

    # check if choice is one of the four options
    if choice in ('1', '2', '3', '4'):
        try:
            num1 = float(input("Enter first number: "))
            num2 = float(input("Enter second number: "))
        except ValueError:
            print("Invalid input. Please enter a number.")
            continue

        if choice == '1':
            print(num1, "+", num2, "=", add(num1, num2))

        elif choice == '2':
            print(num1, "-", num2, "=", subtract(num1, num2))

        elif choice == '3':
            print(num1, "*", num2, "=", multiply(num1, num2))

        elif choice == '4':
            print(num1, "/", num2, "=", divide(num1, num2))

        # check if user wants another calculation
        # break the while loop if answer is no
        next_calculation = input("Let's do next calculation? (yes/no): ")
        if next_calculation == "no":
          break
    else:
        print("Invalid Input")

[ ]
# This function adds two numbers
def add(x, y):
    return x + y

# This function subtracts two numbers
def subtract(x, y):
    return x - y

# This function multiplies two numbers
def multiply(x, y):
â€¦        next_calculation = input("Let's do next calculation? (yes/no): ")
        if next_calculation == "no":
          break
    else:
        print("Invalid Input")

Select operation.
1.Add
2.Subtract
3.Multiply
4.Divide
Enter choice(1/2/3/4): 1
Enter first number: 2
Enter second number: 4
2.0 + 4.0 = 6.0
Let's do next calculation? (yes/no): no


EXCEPTION HANDLING
This video provides an overview of common types of errors encountered in programming, such as syntax errors, runtime errors, and logical errors, and introduces the concept of exception handling. It explains how exceptions can be used to manage unexpected issues during program execution, ensuring the program continues to run smoothly.

Link to Youtube video: https://www.youtube.com/watch?v=6SPDvPK38tw

'''
This line of codes handle errors gracefully each time they occur.
We have different types of errors such as: ZeroDivisionError, ValueError,
TypeError, ImportError, e.t.c.
'''

a = 10
b = 0

try:
    print("Resource Open")
    user_input = int(input("Enter a number: "))
    print(user_input/b)

except ZeroDivisionError as e:
    print("Sorry! You cannot divide a number by zero!", e)

except ValueError as e:
    print("Invalid input value!", e)

except TypeError as e:
    print("Oops! check your typing...", e)

except ImportError as e:
    print("Import error occurred!", e)

except NameError as e:
    print("Name error occurred!", e)

except Exception as e:
    print("Something we nt wrong!", e)

finally:
    print("Resource Closed!")


FILE HANDLING
This video further explains how to open files in different modes, handle file operations efficiently, and ensure proper resource management using context managers.

https://www.youtube.com/watch?v=aequTxAvQq4

# f = open("MyData", "r") # Open a file in read mode for manipulation

# f1 = open('new_file', 'w') # Open a file in write mode for writing contents into it

#copy contents of MyData file into another file
# for data in f:
#     f1.write(data)

# f = open("MyData", "a") # Add more texts into the file using the append mode

# f.write("\nThis is newly Appended")
# print(f.read()) # Reads the entire file and print to the console
# print(f.readline()) # Reads the first line in the file
# print(f.readline(5)) # Reads only the first five characters in the file
# f.write("My name is Ifeanyi\n") # Writes a new line to the file
# f.write("I am a Python programmer\n") # "" "" "" "" "" "" "" ""
# f.write("I am learning file handling\n") # "" "" "" "" "" "" "" ""
# f.write("3MTT Data Science program with Darey.io is the best\n") # "" "" "" "" "" "" "" ""

f2 = open("Myself.jpg", "rb") # Opens the image in a read-byte mode

# print(f2.read()) # Reads byte data. Reads the image as a byte

f3 = open("copied_img.jpg", "wb") # Opens a new image file 

# for loop that copies the contents of Myself.jpg into copied_img.jpg
for i in f2:
    f3.write(i)


EXCEPTION AND FILE HANDLING
As a Python programmer, you'll oftern encounter erros while running your programs. These erros can disrupt the flow of your code, leading to unexpected behavior or crashes. However, Python provides a way to handle these errors gracefully using exception handling.

Exceptions are events (errors) that occur during the execution of a program that disrupts the normal flow of the program's instructions. Instead of letting your program crash, you can use exception handling to deal with these issues in a controlled way.

Link to the file: https://colab.research.google.com/drive/1AfwuZjFi-PzzTnPp0a4E3CaKbOHj5J9Y#scrollTo=7ac7e6b9

1. EXCEPTION HANDLING
As a Python programmer, you'll often encounter errors while running your programs. These errors can disrupt the flow of your code, leading to unexpected behavior or crashes. However, Python provides a way to handle these errors gracefully using exception handling.

Exceptions are events (errors) that occur during the execution of a program that disrupt the normal flow of the program's instructions. Instead of letting your program crash, you can use exception handling to deal with these issues in a controlled way.

Why Handle Exceptions?:

Avoid Crashes: Exception handling ensures that your program doesn't terminate abruptly.
Control Program Flow: It allows you to handle errors and continue executing other parts of your code.
User-Friendly: You can show more informative error messages to the user, improving the overall experience.
Types of Errors in Python
Before diving into exception handling, it's important to understand the two main types of errors:

Syntax errors
Runtime errors
Syntax error OR indentation error
In Syntax error, the error is detected before the program even starts. It occurs when the code structure or syntax is incorrect. For example, missing a colon (:) after an if statement. Syntax errors must be fixed before the code can run.

Indentation error refers to unexpected indents found in the code that are not where they are supposed to be.

print 'Hello'

File "C:\Users\USER\AppData\Local\Temp\ipykernel_8288\3575779984.py", line 1
    print 'Hello'
          ^
SyntaxError: Missing parentheses in call to 'print'. Did you mean print('Hello')?

print('Hello')
    print 'World'

File "C:\Users\USER\AppData\Local\Temp\ipykernel_8288\482772010.py", line 2
    print 'World'
    ^
IndentationError: unexpected indent

if 5 > 3
    print("This will cause a syntax error")

 File "C:\Users\USER\AppData\Local\Temp\ipykernel_2996\585521326.py", line 1
    if 5 > 3
            ^
SyntaxError: invalid syntax

Python expected to find a : but couldn't find any.

Runtime error (AKA exceptions)
These occur during the execution of a program. Even if your program has correct syntax, exceptions can arise due to issues like dividing by zero or trying to access a non-existent file.

It is the type of error that occurs while your program is running. E.g:

ZeroDivisionError
NameError
IndexError
KeyError
AttributeError
TypeError
FileNotFoundError, etc.

print(1)
print(1/0)

1
---------------------------------------------------------------------------
ZeroDivisionError                         Traceback (most recent call last)
~\AppData\Local\Temp\ipykernel_8288\1587665216.py in <module>
      1 print(1)
----> 2 print(1/0)

ZeroDivisionError: division by zero

x = int(input('Enter an integer... '))
print(x)

print('a'+x)

Enter an integer... 4
4
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
~\AppData\Local\Temp\ipykernel_8288\4265484499.py in <module>
      2 print(x)
      3 
----> 4 print('a'+x)

TypeError: can only concatenate str (not "int") to str


Exception Handling in Python: try.....except
try: Run this code
except: Execute this code when there is an exception (error)
else: No exception? Run this code
finally: Always run this code.

try block: This block contains the code you suspect might raise an exception. Python attempts to execute the statements within this block
except block: This comes into play if an exception occurs while executng the try block. The exception itself is an object that carries information about the error. You can define one or more except blocks to handle different types of exceptions

try:
    # Code that might cause an exception
    # For example:
    result = 10 / 0  # This will raise a ZeroDivisionError
except:
    # Code that runs if an exception occurs
    print("An error occurred!")

An error occurred!

try: This keyword tells Python to try running the code inside the try block. Python will keep an eye out for any errors that might happen when running this code.

result = 10 / 0 This line attempts to divide 10 by 0, which is not allowed in mathematics. When Python tries to do this, it will raise a ZeroDivisionError because dividing by zero is impossible. This is an example of an error that would cause a problem in the code.

except: When Python encounters an error (in this case, dividing by zero), it stops the normal execution of the program and jumps to the except block. The except block is where you handle the error and prevent the program from crashing.

print("An error occurred!") If any error occurs in the try block, Python will execute this line. It simply prints a message "An error occurred!" instead of letting the program crash.

SUMMARY:

Python tries to execute the code in the try block.
If an error happens (like dividing by zero), Python jumps to the except block to handle the error.
Instead of crashing, Python prints "An error occurred!".
This helps you handle errors gracefully without stopping the entire program.

text = input('Enter username ')

number = int(text)
print(number)

Enter username Jane
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
~\AppData\Local\Temp\ipykernel_8288\144330832.py in <module>
      1 text = input('Enter username ')
      2 
----> 3 number = int(text)
      4 print(number)

ValueError: invalid literal for int() with base 10: 'Jane'

#Using try except

text = input('Enter username ')

try:
    number = int(text)
    print(number)
except:
    print('Invalid username')

Enter username Jane
Invalid username

What happens is that the code returns a more explanatory error if the code within the try statement encountered some issues. So rather than it crashing the program like we saw above, it simply returns this statement and the user can now get a hint of what they did wrongly. And if there are other lines of code that can run independent of the line that has thrown an error, python moves to them instead.

#Another example

try:
    number = int(input('Enter number '))
    result = number/0
except ZeroDivisionError:
    print('Error: Division by zero!')

Enter number 76
Error: Division by zero!

try with multiple except:
#if try with multiple except blocks is available then the default except
#block should be the last, otherwise we will get a SyntaxError

try:
    x = int(input('Enter first number: '))
    y = int(input('Enter second number: '))
    print(x/y)

except ValueError:
    print('Please enter integer values only')
except ZeroDivisionError:
    print("You can't divide by zero")
except:
    print("I don't know, but something is wrong")
Enter first number: 67
Enter second number: m
Please enter integer values only

single except can handle multiple exceptions:
try:
    x = int(input('Enter first number: '))
    y = int(input('Enter second number: '))
    print(x/y)
except (ZeroDivisionError, ValueError):
    print("Something's wrong")

Enter first number: 34
Enter second number: 0.5
Something's wrong

printing exception as a message:
try:
    print(10/0)
except ZeroDivisionError as message:
    print('Exception:', message)

Exception: division by zero

try:
    x = int(input('Enter first number: '))
    y = int(input('Enter second number: '))
    print(x/y)

except ValueError as message:
    print('Error: ', message)
except ZeroDivisionError as message:
    print("Error: ", message)
except:
    print("I don't know, but something is wrong")

Enter first number: 10
Enter second number: 0
Error:  division by zero

Note that the message variable is not defined beforehand but rather receives its value from the exception object when the exception is raised. This object contains information about the error, including a specific error message.

In simple terms;

You know that error message you would receive when you do not use try..except right? That error message that is usually returned is what is contained in the message variable and therefore printed.

Compare the example above to the one below.

print(10/0)

---------------------------------------------------------------------------
ZeroDivisionError                         Traceback (most recent call last)
~\AppData\Local\Temp\ipykernel_8288\179726827.py in <module>
----> 1 print(10/0)

ZeroDivisionError: division by zero

def add_nums(num1,num2):
    try:
        return (num1+num2)
    except TypeError:
        return('Invalid number')

print(add_nums(1,4))
print(add_nums(45,4))
print(add_nums(1,'a'))
print(add_nums(345678,976377245))

5
49
Invalid number
976722923

From the above, the program does not crash when an exception (AKA error) is encountered.

Using Exception to handle general errors

def add_nums(num1,num2):
    try:
        return (num1+num2222)
    except TypeError:
        return('Invalid number')
    except NameError:
        return('Invalid parameter')

print(add_nums(1,4))
print(add_nums(45,4))
print(add_nums(1,'a'))
print(add_nums(345678,976377245))

Invalid parameter
Invalid parameter
Invalid parameter
Invalid parameter

def add_nums(num1,num2):
    try:
        return (num1+num222)
    except TypeError:
        return('Invalid number')
    except Exception as e:
        return e

print(add_nums(1,4))
print(add_nums(45,4))
print(add_nums(1,'a'))
print(add_nums(345678,976377245))

name 'num222' is not defined
name 'num222' is not defined
name 'num222' is not defined
name 'num222' is not defined

Exception is sort of a default that we use to handle errors that we did not explicitly define as we can see in the difference between both codes above.

Note also that this Exception block should be placed at the every end of all the except statements. If placed at the beginning, the program will not return the specific error messages you may have defined.

def add_nums(num1,num2):
    try:
        return (num1+num2)
    except Exception as e:
        return e

print(add_nums(1,4))
print(add_nums(45,4))
print(add_nums(1,'a'))
print(add_nums(345678,976377245))

G. Exception Handling
As a Python programmer, you'll often encounter errors while running your programs. These errors can disrupt the flow of your code, leading to unexpected behavior or crashes. However, Python provides a way to handle these errors gracefully using exception handling.

Exceptions are events (errors) that occur during the execution of a program that disrupt the normal flow of the program's instructions. Instead of letting your program crash, you can use exception handling to deal with these issues in a controlled way.

Why Handle Exceptions?:

Avoid Crashes: Exception handling ensures that your program doesn't terminate abruptly.
Control Program Flow: It allows you to handle errors and continue executing other parts of your code.
User-Friendly: You can show more informative error messages to the user, improving the overall experience.
Types of Errors in Python
Before diving into exception handling, it's important to understand the two main types of errors:

Syntax errors
Runtime errors
Syntax error OR indentation error
In Syntax error, the error is detected before the program even starts. It occurs when the code structure or syntax is incorrect. For example, missing a colon (:) after an if statement. Syntax errors must be fixed before the code can run.

Indentation error refers to unexpected indents found in the code that are not where they are supposed to be.


[ ]
print 'Hello'


[ ]
print('Hello')
    print 'World'


[ ]
if 5 > 3
    print("This will cause a syntax error")

Python expected to find a : but couldn't find any.

Runtime error (AKA exceptions)
These occur during the execution of a program. Even if your program has correct syntax, exceptions can arise due to issues like dividing by zero or trying to access a non-existent file.

It is the type of error that occurs while your program is running. E.g:

ZeroDivisionError
NameError
IndexError
KeyError
AttributeError
TypeError
FileNotFoundError, etc.

[ ]
print(1)
print(1/0)


[ ]
x = int(input('Enter an integer... '))
print(x)

print('a'+x)

Exception Handling in Python: try.....except
Exception_Handling.png

try block This block contains the code you suspect might raise an exception. Python attempts to execute the statements within this block
except block This comes into play if an exception occurs while executng the try block. The exception itself is an object that carries information about the error. You can define one or more except blocks to handle different types of exceptions

[ ]
try:
    # Code that might cause an exception
    # For example:
    result = 10 / 0  # This will raise a ZeroDivisionError
except:
    # Code that runs if an exception occurs
    print("An error occurred!")
An error occurred!
try: This keyword tells Python to try running the code inside the try block. Python will keep an eye out for any errors that might happen when running this code.

result = 10 / 0 This line attempts to divide 10 by 0, which is not allowed in mathematics. When Python tries to do this, it will raise a ZeroDivisionError because dividing by zero is impossible. This is an example of an error that would cause a problem in the code.

except: When Python encounters an error (in this case, dividing by zero), it stops the normal execution of the program and jumps to the except block. The except block is where you handle the error and prevent the program from crashing.

print("An error occurred!") If any error occurs in the try block, Python will execute this line. It simply prints a message "An error occurred!" instead of letting the program crash.

SUMMARY:

Python tries to execute the code in the try block.
If an error happens (like dividing by zero), Python jumps to the except block to handle the error.
Instead of crashing, Python prints "An error occurred!".
This helps you handle errors gracefully without stopping the entire program.


[ ]
text = input('Enter username ')

number = int(text)
print(number)


[ ]
#Using try except

text = input('Enter username ')

try:
    number = int(text)
    print(number)
except:
    print('Invalid username')
Enter username Jane
Invalid username
What happens is that the code returns a more explanatory error if the code within the try statement encountered some issues. So rather than it crashing the program like we saw above, it simply returns this statement and the user can now get a hint of what they did wrongly. And if there are other lines of code that can run independent of the line that has thrown an error, python moves to them instead.


[ ]
#Another example

try:
    number = int(input('Enter number '))
    result = number/0
except ZeroDivisionError:
    print('Error: Division by zero!')
Enter number 76
Error: Division by zero!
try with multiple except

[ ]
#if try with multiple except blocks is available then the default except
#block should be the last, otherwise we will get a SyntaxError

try:
    x = int(input('Enter first number: '))
    y = int(input('Enter second number: '))
    print(x/y)

except ValueError:
    print('Please enter integer values only')
except ZeroDivisionError:
    print("You can't divide by zero")
except:
    print("I don't know, but something is wrong")
Enter first number: 67
Enter second number: m
Please enter integer values only
single except can handle multiple exceptions

[ ]
try:
    x = int(input('Enter first number: '))
    y = int(input('Enter second number: '))
    print(x/y)
except (ZeroDivisionError, ValueError):
    print("Something's wrong")
Enter first number: 34
Enter second number: 0.5
Something's wrong
printing exception as a message

[ ]
try:
    print(10/0)
except ZeroDivisionError as message:
    print('Exception:', message)
Exception: division by zero

[ ]
try:
    x = int(input('Enter first number: '))
    y = int(input('Enter second number: '))
    print(x/y)

except ValueError as message:
    print('Error: ', message)
except ZeroDivisionError as message:
    print("Error: ", message)
except:
    print("I don't know, but something is wrong")
Enter first number: 10
Enter second number: 0
Error:  division by zero
Note that the message variable is not defined beforehand but rather receives its value from the exception object when the exception is raised. This object contains information about the error, including a specific error message.

In simple terms;

You know that error message you would receive when you do not use try..except right? That error message that is usually returned is what is contained in the message variable and therefore printed.

Compare the example above to the one below.


[ ]
print(10/0)


[ ]
def add_nums(num1,num2):
    try:
        return (num1+num2)
    except TypeError:
        return('Invalid number')

print(add_nums(1,4))
print(add_nums(45,4))
print(add_nums(1,'a'))
print(add_nums(345678,976377245))
5
49
Invalid number
976722923
From the above, the program does not crash when an exception (AKA error) is encountered.

Using Exception to handle general errors

[ ]
def add_nums(num1,num2):
    try:
        return (num1+num2222)
    except TypeError:
        return('Invalid number')
    except NameError:
        return('Invalid parameter')

print(add_nums(1,4))
print(add_nums(45,4))
print(add_nums(1,'a'))
print(add_nums(345678,976377245))
Invalid parameter
Invalid parameter
Invalid parameter
Invalid parameter

[ ]
def add_nums(num1,num2):
    try:
        return (num1+num222)
    except TypeError:
        return('Invalid number')
    except Exception as e:
        return e

print(add_nums(1,4))
print(add_nums(45,4))
print(add_nums(1,'a'))
print(add_nums(345678,976377245))
name 'num222' is not defined
name 'num222' is not defined
name 'num222' is not defined
name 'num222' is not defined
Exception is sort of a default that we use to handle errors that we did not explicitly define as we can see in the difference between both codes above.

Note also that this Exception block should be placed at the every end of all the except statements. If placed at the beginning, the program will not return the specific error messages you may have defined.


[ ]
def add_nums(num1,num2):
    try:
        return (num1+num2)
    except Exception as e:
        return e

print(add_nums(1,4))
print(add_nums(45,4))
print(add_nums(1,'a'))
print(add_nums(345678,976377245))

5
49
unsupported operand type(s) for +: 'int' and 'str'
976722923

User defined exceptions - Part 1
These are exceptions that we can define in our program when we want our program to cause an exception depending on certain conditions. We do this using raise error.

def add_nums(num1,num2):
    return (num1+num2)


print(add_nums(1,4))
print(add_nums(45,4))
print(add_nums('b','a'))
print(add_nums(345678,976377245))

5
49
ba
976722923

#I want to handle cases where the values entered are not integers or floats

def add_nums(num1,num2):
    try:
        if (num1 == int(num1) or num1 == float(num1)) and (num2 == int(num2) or num2 == float(num2)):
            return num1+num2
        else:
            raise Exception('Only int and float values are allowed')
    except Exception as e:
        return e

print(add_nums(1,4))
print(add_nums(45,4))
print(add_nums('b','a'))
print(add_nums(345678,976377245))

5
49
invalid literal for int() with base 10: 'b'
976722923

This does not work as expected because when the if condition runs and results in false (non-numeric inputs), the code simply continues without reaching the raise Exception. Let's fix this.

def add_nums(num1,num2):
    try:
        if (isinstance(num1, (int, float)) and isinstance(num2,(int, float))):
            return num1+num2
        else:
            raise Exception('Only int and float values are allowed')
    except Exception as e:
        return e

print(add_nums(1,4))
print(add_nums(45,4))
print(add_nums('b','a'))
print(add_nums(345678,976377245))

5
49
Only int and float values are allowed
976722923

The isinstance function is used for type checking in a more robust way compared to the direct comparison like num1==int(num1). It also solves our intial problem.

try....except with finally and else
For else, it is such that if the try block executes successfully, it calls it. That is if the try block does not throw an exception, then call the else part.

'finally' block will always be executed when you have your try statement.

def add_nums(num1,num2):
    try:
        print (num1+num2)
    except TypeError:
        print('Invalid number')
    except Exception as e:
        print(e)
    else:
        print('Successful...')

add_nums(1,4)

5
Successful...

def add_nums(num1,num2):
    try:
        print (num1+num2)
    except TypeError:
        print('Invalid number')
    except Exception as e:
        print(e)
    else:
        print('Successful...')
    finally:
        print('The End!')

add_nums(1,'the')

Invalid number
The End!

Nested try....except....finally
This is used to handle exceptions in a more granular way within python code. They allow you to create multiple layers of error handling, providing specific actions for different types of exceptions that might occur at different parts of your code.

def open_and_read_file(filename):

    #outer try block
    try:

        #inner try block
        try:
            with open(filename, 'r') as f:
                contents = f.read()
            return contents
        except FileNotFoundError as e:
            print(f"Error: File '{filename}' not found.")

    except Exception as e:
        print(f"An unexpected error occured: {e}")
    finally:
        print('File operation complete')

Here, the outer try block handles general exceptions that might occur during file operations.

The inner try block specifically catches the FileNotFoundError and provides a more informative messsage.

finally block ensures the "File operations complete" message is printed regardless of success or failure.

User defined exceptions - Part 2
Recall that we use raise Exception to raise our own errors. That is just a bit of what can be done.

age = int(input('Enter your age: '))

try:
    if age < 10:
        print('You are too young!')
        raise ZeroDivisionError ('get out')

except ZeroDivisionError as message:
    print(message)

Enter your age: 9
You are too young!
get out

In this second case, we are exploring another form of user defined functions AKA customized exceptions. Here, the programmer, in this case myself, is responsible to define and raise these exceptions.

## remember what we learnt about inheritance in OOP right?
#you can see here that the TooYoungException I created
#inherits its characteristics from the Exception parent class


class TooYoungException(Exception):
    def __init__(self, msg):
        self.msg = msg

age = int(input('Enter your age: '))

try:
    if age < 10:
        raise TooYoungException('You are too young!')
    else:
        print('You can proceed!')

except TooYoungException as msg:
    print(msg)

Enter your age: 5
You are too young!



2. FILE HANDLING

i. Opening files
ii. Reading from files
iii. Writing to files
iv. Adding or Appending to files
v. Closing the files

In many programs, you will need to read data from a file or save data to a file. This process is called file handling. Python makes file handling easy by providing built-in functions that allow you to open, read, write, and close files efficiently.

Files can be of various types, such as text files (.txt), CSV files, or binary files. Python provides several functions to work with these files, and the most common tasks include reading from files, writing to files, and appending data to files.

Basic Concepts of File Handling
Before jumping into the code, letâ€™s go over some basic concepts related to file handling:

File: A file is a collection of data stored in a storage device, such as a hard disk.
File Path: This is the location of the file in your system, for example, C:/Documents/file.txt on Windows or /home/user/file.txt on Linux/Mac.
File Modes: When opening a file, you need to specify the mode in which you want to interact with the file:

File Mode	Description
r	Open for reading (default)
w	Open for writing, truncating existing content
x	Create a new file and open for writing, fail if exists
a	Open for appending, create new file if it doesn't exist
r+	Open for reading and writing, existing content can be modified
w+	Open for reading and writing, existing content is deleted
a+	Open for reading and appending, existing content is preserved
b	Open in binary mode (combine with other modes like 'rb' or 'wb')

File object properties:
f = open('sample_data.txt', 'w')

print('File name:', f.name)
print('File mode:', f.mode)
print('Is file readable? ', f.readable())
print('Is file writable? ', f.writable())
print('Is file closed? ', f.closed)

f.close()

print('Is file closed now? ', f.closed)

File name: sample_data.txt
File mode: w
Is file readable?  False
Is file writable?  True
Is file closed?  False
Is file closed now?  True

read() -> read all the data:
#reading data from files

f = open('sample_data2.txt', 'r')
data = f.read()

print(data)
f.close()

Hello!
Welcome to this notebook!
This is a sample data for my 'data science relearning the fundamentals' project.
My name is Hannah Igboke. I am a data analyst/scientist. What about you?
A big fan of Harry Potter and GOT book series.
I would work at NASA someday in the future.
What are you doing to cushion the effects of the current economic situation of the country.

read(n) -> read n number of characters:
f = open('sample_data2.txt', 'r')
data = f.read(15)

print(data)
f.close()

Hello!
Welcome

readline() -> read only the first line:

f = open('sample_data2.txt', 'r')
line1 = f.readline()

line2 = f.readline()

print(line1)
print(line2)

Hello!

Welcome to this notebook!

f = open('sample_data2.txt', 'r')

lines = f.readlines()

for l in lines:
    print(l)

Hello!

Welcome to this notebook!

This is a sample data for my 'data science relearning the fundamentals' project.

My name is Hannah Igboke. I am a data analyst/scientist. What about you?

A big fan of Harry Potter and GOT book series.

I would work at NASA someday in the future.

What are you doing to cushion the effects of the current economic situation of the country.

type(lines)

list

Write data to text files:

f = open('sample_data.txt', 'a')

f.write(' abc')
f.write(' cat and mouse')
f.write(' LLM')

data = f.read()
print(data)

f.close()

---------------------------------------------------------------------------
UnsupportedOperation                      Traceback (most recent call last)
~\AppData\Local\Temp\ipykernel_10024\941956916.py in <module>
      5 f.write(' LLM')
      6 
----> 7 data = f.read()
      8 print(data)
      9 

UnsupportedOperation: not readable

Keep this error in mind

Remember the error earlier, after appending data to the txt file we could not read the data from the file. To resolve this we use the r+ mode. It opens a file for reading and writing, and existing content can be modified.

f = open('sample_data.txt', 'r+')

data = f.read()
print(data)

f.write(' Alphabets, Animals and LLM!')

f.close()

abc cat and mouse LLM

f =open('sample_data.txt')

data = f.read()
print(data)
f.close()

[ ]
f =open('sample_data.txt')

data = f.read()
print(data)
f.close()

 abc cat and mouse LLM Alphabets, Animals and LLM!

# writelines takes a sequence

f = open('sample_data.txt3', 'w')

lines = ['line1', 'line2', 'line3']

f.writelines(lines)
f.close()

<function TextIOWrapper.close()>

Using with statement:
It provides a concise and safe way to handle file opening, closing and potential exceptions in file handling.

with open('sample_data.txt', 'a') as f:
    lines = ['Line1', 'Line2', 'Line3']
    f.writelines(lines)

    #checking if the file has been closed at this point - remeber that we are still inside the with statement block
    print('Is file closed at this point? ', f.closed)

#now we are outside the with block
print('How about now? ', f.closed)

Is file closed at this point?  False
How about now?  True

 abc cat and mouse LLM Alphabets, Animals and LLM!Line1Line2Line3

Using seek() and tell():
Used to mainpulate the file pointer's position within a file object.

seek(offset, whence=0)
Used to move the file pointer to a new position within the file. It takes two arguments:

offset: an integer specifying the number of bytes to move the file pointer. It can be +ve(to move forward), -ve(backward) or 0.
whence(optional): an integer value that defines the reference point from which the offset is to be applied. It defaults to 0 (referencing the beginning of the file) Some common values for whence include:

0: move to beginning of the file (SEEK_SET)
1: move from the current position of the file pointer (SEEK_CUR)
2: move to the end of the file (SEEK_END)

with open('sample_data2.txt', 'r+') as f:

    #reading the first 5bytes
    data = f.read(5)
    print(data)

    #moving the pointer 10bytes forward from the current position
    f.seek(10,0)

    #reading the next 10 bytes
    data = f.read(10)
    print(data)

Hello
lcome to t

tell():
This method returns the current position of the file pointer within the file as an integer number of bytes. It simply tells you where the file pointer is currently located.

with open('sample_data2.txt', 'r+') as f:
    print('Current pointer position: ',f.tell())
    text = f.read()

    print('Current pointer position: ',f.tell())
    f.seek(2)

    f.write('The End!')

    print('Current pointer position: ',f.tell())

Current pointer position:  0
Current pointer position:  377
Current pointer position:  10

Renaming and deleting files:
import os

os.rename('sample_data2.txt', 'my_data.txt')

##to remove a file

#os.remove('sample_data2.txt')

Splitting lines:
with open('my_data.txt', 'r') as f:
    lines = f.readlines()

    for l in lines:
        words = l.split()
        print(words)

['Hello!']
['Welcome', 'to', 'this', 'notebook!']
['This', 'is', 'a', 'sample', 'data', 'for', 'my', "'data", 'science', 'relearning', 'the', "fundamentals'", 'project.']
['My', 'name', 'is', 'Hannah', 'Igboke.', 'I', 'am', 'a', 'data', 'analyst/scientist.', 'What', 'about', 'you?']
['A', 'big', 'fan', 'of', 'Harry', 'Potter', 'and', 'GOT', 'book', 'series.']
['I', 'would', 'work', 'at', 'NASA', 'someday', 'in', 'the', 'future.']
['What', 'are', 'you', 'doing', 'to', 'cushion', 'the', 'effects', 'of', 'the', 'current', 'economic', 'situation', 'of', 'the', 'country.']



TASKS:
1. Write a Python program to copy the contents of a file to another file

with open('data1.txt', 'a') as f1:
    with open('my_data.txt', 'r') as f2:
        data = f2.read()
    f1.write(data)

#to check if it worked
f = open('data1.txt', 'r')
print(f.read())

f.close()

Hello!
Welcome to this notebook!
This is a sample data for my 'data science relearning the fundamentals' project.
My name is Hannah Igboke. I am a data analyst/scientist. What about you?
A big fan of Harry Potter and GOT book series.
I would work at NASA someday in the future.
What are you doing to cushion the effects of the current economic situation of the country.


## Anoother way to write the code above

with open('my_data.txt', 'r') as f1, open('my_data2.txt', 'w') as f2:
    for line in f1:
        f2.write(line)

#to check if it worked
f = open('my_data2.txt', 'r')
print(f.read())

f.close()

Hello!
Welcome to this notebook!
This is a sample data for my 'data science relearning the fundamentals' project.
My name is Hannah Igboke. I am a data analyst/scientist. What about you?
A big fan of Harry Potter and GOT book series.
I would work at NASA someday in the future.
What are you doing to cushion the effects of the current economic situation of the country.

2. Write a Python program to combine each line from first file with the corresponding line in second file.

with open('data1.txt', 'r') as f1:
    lines1 = f1.readlines()
    for line in lines1:
        print(line)
    with open ('numbers.txt', 'r') as f2:
        lines2 = f2.readlines()
        for line in lines2:
            print(line)

Hello!

Welcome to this notebook!

This is a sample data for my 'data science relearning the fundamentals' project.

My name is Hannah Igboke. I am a data analyst/scientist. What about you?

A big fan of Harry Potter and GOT book series.

I would work at NASA someday in the future.

What are you doing to cushion the effects of the current economic situation of the country.

1234567890

0987654312

12345

654329

09876123

43567

This code does not produce the intended output so I'll try again.

I am trying to iterate through two files line by line parallelly. I can resolve this using the zip function.

with open('data1.txt', 'r') as f1, open('numbers.txt', 'r') as f2:
    for line1, line2 in zip(f1,f2):
        combined_line = line1+line2
        print(combined_line)

Hello!
1234567890

Welcome to this notebook!
0987654312

This is a sample data for my 'data science relearning the fundamentals' project.
12345

My name is Hannah Igboke. I am a data analyst/scientist. What about you?
654329

A big fan of Harry Potter and GOT book series.
09876123

I would work at NASA someday in the future.
43567

What are you doing to cushion the effects of the current economic situation of the country.
89321

3. Write a Python program to write 10 random numbers into a file. Read the file and then sort the numbers and then store it to another file.

import random
help(random.randrange)

Help on method randrange in module random:

randrange(start, stop=None, step=1) method of random.Random instance
    Choose a random item from range(start, stop[, step]).
    
    This fixes the problem with randint() which includes the
    endpoint; in Python this is usually not what you want.

import random

with open('new_data2.txt', 'w') as f3:
    with open('new_data.txt', 'x') as f1:
        for i in range(10):
            f1.write(str(random.randrange(0,100, 2))+'\n')

    with open('new_data.txt', 'r') as f2:
        data = []
        for line in f2:
            data.append(int(line.strip()))
        data.sort()

    for num in data:
        f3.write(str(num)+'\n')

f = open('new_data.txt', 'r')

data = f.read()
print(data)
f.close()

[ ]
f = open('new_data.txt', 'r')

data = f.read()
print(data)
f.close()
68
84
50
42
46
66
40
56
84
30

f = open('new_data2.txt', 'r')

data = f.read()
print(data)
f.close()

30
40
42
46
50
56
66
68
84
84


Importing numpy in python:
# Using numpy -- Used for cases where the data file contains numerical records.

import numpy as np
filename = 'heights.txt'
data = np.loadtxt(filename, delimiter = ',', skiprows=1, usecols=[0,2], dtype=str)
#where usecols is the list of the column indices you want to remove.

By mastering file handling, you can efficiently work with data stored in files, making your programs more powerful and flexible!



REGULAR EXPRESSIONS IN PYTHON
The content covers how to craft regular expressions and key concepts such as quantifiers for controlling match counts, functions like match and full match, and grouping techniques to label parts of a regex.

Link to the video: https://www.youtube.com/watch?v=nxjwB8up2gI

Regular expression (REGEX) is a tool used in text processing to describe and match patterns in strings. It is a sequence of characters that defines a search pattern.

Link to the Article: https://colab.research.google.com/drive/1eZv8eM2pzDKKzylefIBitTDLafTVGyeX#scrollTo=4bf56970

WHAT IS REGULAR EXPRESSION?
Regular expression is a tool used in text processing to describe and match patterns in strings. It is a sequence of characters that defines a search pattern.

Why is it useful?
Pattern matching: to search for specific patterns within a larger body of text. E.g finding specific words, dates, email addresses and other strutured information.
Text extraction: useful to extract pieces of information from a document. This information can be anything from a house address to most repeeated phrases in a document.
Data validation & pattern validation: useful for validating input data. E.g, checking if the phone number matches the 11 didgit pattern for nigerian contact numbers. It us used to validate whether an input adheres to a format, such as checking if a password being created has at least one capital letter, a digit and special symbols.
Search and replace: useful for cases where you need to replace specific patterns with something else. This is especially useful in data cleaning and transformation.
Web scraping and data extraction: to locate and extract specific elements and information/data from HTML pages
Parsing and tokenization: to break down text into smaller units or tokens. Useful in NLP problems.
Log file analysis: used in searching and parsing log files, allowin you to extract important information or identify patterns of interest.
Search engines and information retrieval: used for matching user queries to relevant content on websites or databases
URL routing and validation: useful for validating URLs to ensure they follow the correct format and extracting speicuf parameters from them
Network security and firewall rules: it allows the ability to define custom rules for allowing or blocking specific types of traffic nbased on patterns in network traffic logs
Extracting meta data from documents: by parsing documents like PDFs and word documents regex can extract metadata like the titles, authors, etc
URL rewriting in web servers: modifying URLs on the fly to improve SEO or to direct traffic to specific pages
User-defined character
[abc] - match either a,b/c

[^abc] - match any character asides a,b, or c

[a-z] - match lower case alphabet

[A-Z] - match upper case alphabet

[a-zA-Z] - matches any english alphabet - whether lower case or upper case

[0-9] - matches any digit character

[a-zA-Z0-9_] - matches any alphanumeric character

[^a-zA-Z0-9_] - matches any character except alphanumeric characters

NOTE:

The pattern [abc] will only match a single a,b, or c letter and nothing else. Therefore, remember to put in the actual string you want to serach for inside the square brackets.

Dash - is used to define the character range, so we can still have [0-6] as well

Pre-defined characters
They can serve as alternatives to the above.

\d = [0-9]: matches a digit character
\D = [^0-9]: matches any character except digit characters
\w = matches an alphanumeric character
\W = matches any character that is not alphanumeric
\s = matches a space character
\S = match any character except space
\t = matches a tab character
\n = matches a newline character
\r = matches a carriage return
Quantifiers
To determine how much or how many of those characters you want to search for

* = matches 0 or more number of characters, useful for cases where the character might be there or not
+ = matches 1 or more number of characters, i.e, it checks for cases where the character appears at anywhere from once to as many times as possible
? = matches atmost 1 character, i.e 0 or 1, it indicates that the string to be matched is optional
a{n} = matches excatly n number of characters
a{m,n} = matches at least m number and at most n number of characters
NOTE: You can have \d+, \d*, \d{5}

Meta Characters
Refers to characters/symbols that are like special key characters. This is to say that if you were to encounter any of them in a document you will need to use \ before it to tell the regex matcher that it is an actual symbol in the document you want to find.

., ^, *, +, ?, {}, (), |, \, $,

^....$ = starting and ending. ^ indicates the start of the string to search for, $ indicates that we have come to a stop
(string) = () are used for matching groups. It is such that we define groups of characters and capture them using () metacharacter. Any subpattern inside a pair of () will be captured as a group
(abc(cv)) = capturing sub groups AKA nested groups
(abc|cvb) = capturing conditionals to denote possible sets of characters
\b = matches boundary between a word and a non-word character, e.g space or a newline. It is useful in capturing entire words (for example by using the pattern \w+\b)
.* = captures all. This captures all the string in a document
For example:

ab?c = could be abc or ac, b is an optional charcter to search for
Searching for "success" in a log file that also contains instances of "unsuccessful". Pattern to search for will be = ^success$

"file_record_transcript.pdf" and "file_07241999.pdf" We need to write a regex that matches only filenames (not including the pdf files). Pattern will be = ^(file_[a-z0-9]*([_a-z]?)+)

Searching for instances of "Buy more milk", "Buy more bread", "Buy more juice" The pattern would be "Buy more (milk|bread|juice)"

Importing the required module:

import re

help(re)

re.fullmatch():
Returns a match object if and only if the entire string matches the pattern. Otherwise, it will return None. This is useful for vaidating data.

#Syntax:

import re
re.fullmatch(pattern, string)

1. Regex to match a Nigerian contact number

Rules:

It should start with 0

It should contain exactly 11 digits

#asking for input 
mobile_num = input('Enter your Nigerian mobile number: ')

#defining the expression/pattern fpr Nigerian phone numbers
regex = r'^(0)[7-9]\d{9}$'

#match the regex with the user entered mobile number
match = re.fullmatch(regex, mobile_num)

#Check to know if the number entered is valid or not
if match:
    print('Your number is Valid!')
else:
    print('Not valid!')

Enter your Nigerian mobile number: 091234567890987
Not valid!

Note:

[7-9] is used to ensure that the first number after the leading 0 belongs to a mobile operator.

Preceding r in a string

The "r" at the start of the pattern string is used to designate a python "raw" string. It means that the string is to be treated as a raw string which means all escape codes will be ignored.

For example: \n will be treated as a newline character while r'\n refers to the characters \ followed by n.

2. Regex to match to validate a python identifier (AKA user-defined names)

Rules:

Can be a combination of letters(uppercase and lowercase),digits(0-9)

Must start with a letter or an underscore. Digits cannot be the first character.

No special characters are allowed except _

Reserved words or keywords are not allowed

#create a list of python keywords
keywords = ["True", "False", "None", "and", "or", "not", "in", "is", 
            "if", "elif", "else", "for", "while", "break", "continue", 
            "pass", "def", "class", "with", "as", "lambda", "return", 
            "yield", "import", "from", "try", "except", "raise", "finally", "assert", "async", "await"]

#asking for input 
my_identifier = input('Enter python identifier: ')

#defining the expression/pattern fpr Nigerian phone numbers
regex = r"^[a-zA-Z_][\w\_]*"

#match the regex with the user entered mobile number
match = re.fullmatch(regex, identifier)

#Check to know if the number entered is valid or not
if my_identifier in keywords:
    print('You have entered a python keyword. Please revise.')
elif match:
    print('Valid!')
else:
    print('Not valid!')

Enter python identifier: break
You have entered a python keyword. Please revise.

re.findall():
It iterates over a string(document) to find a subset of characters that match a specified pattern. It will return a list of every pattern match that occurs in a given string. The string is scanned L-to-R, and matches are returned in the order found. Useful for tasks like data extraction and data cleaning.

#Syntax:

import re
re.findall(pattern, string)

import re

string = """
        Hello, my email is john.doe@example.com. 
        For more information, contact me at john.doe+info@example.com. 
        You can also reach out to my colleague at jane.doe@example.co.uk.
        For general inquiries, please contact us at info4567@example.com. 
        For technical support, reach out to support@example.com. 
        For sales inquiries, email sales@example.com. 
        For partnership opportunities, contact us at partners@example.com.
        """
#extract all email addresses from the string
regex = r"[\w\.\+]+\@[\w]+\.[a-z\.]+"

re.findall(regex, string)

['john.doe@example.com.',
 'john.doe+info@example.com.',
 'jane.doe@example.co.uk.',
 'info4567@example.com.',
 'support@example.com.',
 'sales@example.com.',
 'partners@example.com.']

Search and replace
re.sub

#Syntax:

re.sub(pattern, replacement, targetString)

import re
new = re.sub('\d', '#', 'a1b2c3d4e4f6&*%')
new

'a#b#c#d#e#f#&*%'

#re.sub(regex, replacement, targetString)

import re
phone = '123-1234-546-980. This is my phone number'

#removing the text part of the string
num1 = re.sub('[a-zA-Z\.]+', '', phone)
print('Num1: ', num1)

#replacing - with |
num2 = re.sub('[\-]+', '|', phone)
print('Num2: ', num2)

Num1:  123-1234-546-980     
Num2:  123|1234|546|980. This is my phone number

re.split():
#Syntax:

re.split(pattern, string)

import re
line = re.split('\W', 'abcdef&ghij+1234@gmail.com')
print(line)

['abcdef', 'ghij', '1234', 'gmail', 'com']

Step by Step for creating RegEx:

Step 1: Create the pattern object
#compile() ->> converts the pattern into regex object

import re
pattern = re.compile('Python')

print(type(pattern))

<class 're.Pattern'>

Step 2: Create matcher object:

matcher = pattern.finditer('Does Python use Object Oriented Programming? How many Python libraries do you know of? Python and python')

print(type(matcher))

<class 'callable_iterator'>

Step 3: Iterate over the matcher:

#start() -> starting index of matched string
#end() -> end+1 index
#group() -> returns matched string

for m in matcher:
    print(type(m))
    print('Match is at: {}, End: {}, Pattern found: {}'.format(m.start(), m.end(), m.group()))
print('DONE!')

<class 're.Match'>
Match is at: 5, End: 11, Pattern found: Python
<class 're.Match'>
Match is at: 54, End: 60, Pattern found: Python
<class 're.Match'>
Match is at: 87, End: 93, Pattern found: Python
DONE!

Using various combinations:

The one we just saw above is the first one.

#2nd way

import re

matcher = re.compile('Python').finditer('Does Python use Object Oriented Programming? How many Python libraries do you know of? Python and python')

for m in matcher:
    print('Match is at: {}, End: {}, Pattern found: {}'.format(m.start(), m.end(), m.group()))

Match is at: 5, End: 11, Pattern found: Python
Match is at: 54, End: 60, Pattern found: Python
Match is at: 87, End: 93, Pattern found: Python

#3rd way =>> re.finditer(pattern, target)

import re

matcher = re.finditer('Python', 'Does Python use Object Oriented Programming? How many Python libraries do you know of? Python and python')
for m in matcher:
    print('Match is at: {}, End: {}, Pattern found: {}'.format(m.start(), m.end(), m.group()))

Match is at: 5, End: 11, Pattern found: Python
Match is at: 54, End: 60, Pattern found: Python
Match is at: 87, End: 93, Pattern found: Python

import re
matcher = re.finditer('Python','Does Python use Object Oriented Programming? How many Python libraries do you know of? Python and python')

count = 0

for m in matcher:
    count += 1
    print('Match is at: {}, End: {}, Pattern found: {}'.format(m.start(), m.end(), m.group()))
print('Total patterns found: ', count)

Match is at: 5, End: 11, Pattern found: Python
Match is at: 54, End: 60, Pattern found: Python
Match is at: 87, End: 93, Pattern found: Python
Total patterns found:  3

matcher = re.finditer('[^a-z]', 'a4b&u_lkegy/>+ Deciimal points#@')

count = 0

for m in matcher:
    count += 1
    print('Match is at: {}, End: {}, Pattern found: {}'.format(m.start(), m.end(), m.group()))
print('Total patterns found: ', count)

Match is at: 1, End: 2, Pattern found: 4
Match is at: 3, End: 4, Pattern found: &
Match is at: 5, End: 6, Pattern found: _
Match is at: 11, End: 12, Pattern found: /
Match is at: 12, End: 13, Pattern found: >
Match is at: 13, End: 14, Pattern found: +
Match is at: 14, End: 15, Pattern found:  
Match is at: 15, End: 16, Pattern found: D
Match is at: 23, End: 24, Pattern found:  
Match is at: 30, End: 31, Pattern found: #
Match is at: 31, End: 32, Pattern found: @
Total patterns found:  11

matcher = re.finditer('a*', 'abaaaahytajkoaaa7ytaaaweraasdfgaa')

count = 0

for m in matcher:
    count += 1
    print('Match is at: {}, End: {}, Pattern found: {}'.format(m.start(), m.end(), m.group()))
print('Total patterns found: ', count)

Match is at: 0, End: 1, Pattern found: a
Match is at: 1, End: 1, Pattern found: 
Match is at: 2, End: 6, Pattern found: aaaa
Match is at: 6, End: 6, Pattern found: 
Match is at: 7, End: 7, Pattern found: 
Match is at: 8, End: 8, Pattern found: 
Match is at: 9, End: 10, Pattern found: a
Match is at: 10, End: 10, Pattern found: 
Match is at: 11, End: 11, Pattern found: 
Match is at: 12, End: 12, Pattern found: 
Match is at: 13, End: 16, Pattern found: aaa
Match is at: 16, End: 16, Pattern found: 
Match is at: 17, End: 17, Pattern found: 
Match is at: 18, End: 18, Pattern found: 
Match is at: 19, End: 22, Pattern found: aaa
Match is at: 22, End: 22, Pattern found: 
Match is at: 23, End: 23, Pattern found: 
Match is at: 24, End: 24, Pattern found: 
Match is at: 25, End: 27, Pattern found: aa
Match is at: 27, End: 27, Pattern found: 
Match is at: 28, End: 28, Pattern found: 
Match is at: 29, End: 29, Pattern found: 
Match is at: 30, End: 30, Pattern found: 
Match is at: 31, End: 33, Pattern found: aa
Match is at: 33, End: 33, Pattern found: 
Total patterns found:  25

re.match():
re.match(pattern, target)

It is used to match the given patern at the beginning of the target string. If it finds the pattern it returns the match object. If nothing is found, it returns None.

import re

regex = input('Enter pattern to search for: ')

m = re.match(regex, 'abcdefghijk')

if m == None:
    print('Match is not available at the beginning of the string')
else:
    print('Match found at the beginning of the string.')
    print('Match is at: {}, End: {}, Pattern found: {}'.format(m.start(), m.end(), m.group()))

Enter pattern to search for: efg
Match is not available at the beginning of the string.

re.search():
re.search(pattern, target)

Searches the target string irrespective of location. If match is found it returns the first occurrence, otherwise it returns None

import re

regex = input('Enter pattern to search for: ')

m = re.search(regex, 'abcdefghijk')

if m != None:
    print('Match available!')
    print('First occurence at: {}, End: {}, Pattern found: {}'.format(m.start(), m.end(), m.group()))
else:
    print('Match was not found in the entire sring.')

Enter pattern to search for: efghi
Match available!
First occurence at: 4, End: 9, Pattern found: efghi.

Ignoring the case of the pattern:
import re
I = re.IGNORECASE  #You can refer to the help(re) results above to understand how to use flags in regex

string = 'I am learning Python'

match = re.search('python$', string, I)

if match:
    print('Nice!')
else:
    print('OopsðŸ™‚')

Nice!



PHYTHON API TUTORIAL
Learn how to seamlessly retrieve and integrate data from various sources using Python. Explore essential concepts, best practices, and hands-on examples to confidently work with APIs.

An API simply connects apps together. There is usually a documentation available for any API documentation you are to use. It is important that you give them a read.

API's are also used to retrieve data from remote websites. To use an API, you make a request to a remote web server and retrieve the data you need. We use API in cases where the data quickly changes, e.g., stock market data or in cases where we want a small piece of a much larger dataset, e.g., twitter.

https://colab.research.google.com/drive/1sClipn7IHQOisKi8DlIupBuP89C_O_NC


APPLICATION PROGRAMMING INTERFACE (API)
An API simply connects apps together. There is usually a documentation available for any API documentation you are to use. It is important that you give them a read. API's are also used to retrieve data from remote websites. To use an API, you make a request to a remote web server and retrieve the data you need. We use API in cases where the data quickly changes, e.g., stock market data or in cases where we want a small piece of a much larger dataset, e.g., twitter.

Some communication protocols

FTP - File Transfer Protocol
SFTP - Secure File Transfer Protocol
SMTP - Simple Mail Transfer Protocol
HTTP - Hyper Text Transfer Protocol
HTTPS - Secure HTTP
HTTP request modes include: POST(create), GET(read/retrieve), PUT(update) and DELETE(delete).

API Endpoint: is a digital location where an API receives requests about a specific resource on its server.

Making an API request

To get data, we make a HTTP request to a webserver
The server then replies with our data. The requests module in python is used to do this
There are many different we can make as well. GET request is the most common, used to retrieve data.
The image below provides a breakdown of the components of a URL

#How to send a request to open Google home page in python

import requests
URL = 'https://google.com'
response = requests.get(URL)


#Alternatively, to send a request to open Google home page,
#you simply open your browser, type google.com in the url secton and hit enter

Request and Response from Google Web server:
#import library
import requests

#make a get request to fetch search results on 'hannah igboke'

response = requests.get('https://google.com/search?q=hannah+igboke')

#printing response headers

print(response.headers)

{'Content-Type': 'text/html; charset=ISO-8859-1', 'Date': 'Fri, 10 May 2024 14:38:29 GMT', 'Expires': '-1', 'Cache-Control': 'private, max-age=0', ...'}

#checking the response url

print(response.url)

https://www.google.com/search?q=hannah+igboke

#check the status code of the response

print(response.status_code)

#200 means it was successful

200

#checking response encoding

print(response.encoding)

ISO-8859-1

#retrieving header properties the response content type

print(response.headers['Content-Type'])
print(response.headers['Cache-Control'])

text/html; charset=ISO-8859-1
private, max-age=0

#text response content
#this is useful if the response body contains text data

print(response.text[0:100])

#you can also try
#print(response.text)

<!doctype html><html lang="en-NG"><head><meta charset="UTF-8"><meta content="/images/branding/google>

#for cases where the response body contains non-text data
# binary response content

print(response.content[0:100])

b'<!doctype html><html lang="en-NG"><head><meta charset="UTF-8"><meta content="/images/branding/google'>

#JSON response content

print(response.json())

JSONDecodeError                           Traceback (most recent call last)
~\anaconda3\lib\site-packages\requests\models.py in json(self, **kwargs)
    970         try:
--> 971             return complexjson.loads(self.text, **kwargs)
    972         except JSONDecodeError as e:

~\anaconda3\lib\json\__init__.py in loads(s, cls, object_hook, parse_float, parse_int, parse_constant, object_pairs_hook, **kw)
    345             parse_constant is None and object_pairs_hook is None and not kw):
--> 346         return _default_decoder.decode(s)
    347     if cls is None: ...


Status code:
1xx = information

2xx = success

3xx = redirection

301: the server is redirecting you to a different endpoint. This happens when a company switches domain names or an endpoint name is changed
4xx = client error

400: bad request caused by not sending the right details
401: server thinks you're not authenticated. This happens when you don't send the right credentials to access an API
403: resource you're trying to access is forbidden. You don't have the right permission to access it
404: the resource tried was not found on the server
5xx = server error

#trying an endpoint that does not exist

response = requests.get('https://google.com/abcd')
print(response.status_code)

#an ednpoint that exists
response = requests.get('https://google.com/search')
print(response.status_code)

404
200

Query parameters:

#request without query parameter

import requests
response = requests.get('https://google.com/search')
print(response.status_code)

200

#request with query parameter

import requests

parameters = {'q': 'Hannah Igboke'}
response = requests.get('https://google.com/search', params = parameters)
print(response.status_code)

200

Request and Response from ISS API:
Using OpenNotify API. It has several API endpoints. Like I mentioned earlier, you can find the other API endpoints in the documentation: http://open-notify.org/Open-Notify-API/.

Endpoints:

/iss-now.json
This api returns the current location of the ISS. It returns the current latitude and longitude of the space station with a unix timestamp for the time the location was valid. This API takes no inputs. Remember that this data is not static and changes rapidly.

#making a request to get the latest position of ISS from the opennotify api

import requests
response = requests.get('http://api.open-notify.org/iss-now.json')
print(response.headers)
print(response.url)
print(response.status_code)
print(response.encoding)

{'Server': 'nginx/1.10.3', 'Date': 'Thu, 09 May 2024 19:01:46 GMT', 'Content-Type': 'application/json', 'Content-Length': '113', 'Connection': 'keep-alive', 'access-control-allow-origin': '*'}
http://api.open-notify.org/iss-now.json
200
utf-8

#printing text content

print(response.text)

{"message": "success", "iss_position": {"latitude": "-8.4779", "longitude": "-14.5603"}, "timestamp": 1715281306}

#printing binary content

print(response.content)

b'{"message": "success", "iss_position": {"latitude": "-8.4779", "longitude": "-14.5603"}, "timestamp": 1715281306}'

#printing json content

print(response.json())

{'message': 'success', 'iss_position': {'latitude': '-8.4779', 'longitude': '-14.5603'}, 'timestamp': 1715281306}

/astros.json
This API returns the current number of people in space.


import requests

response = requests.get('http://api.open-notify.org/astros.json')
print(response.headers)

{'Server': 'nginx/1.10.3', 'Date': 'Thu, 09 May 2024 19:12:12 GMT', 'Content-Type': 'application/json', 'Content-Length': '360', 'Connection': 'keep-alive', 'access-control-allow-origin': '*'}

data = response.json()

print(type(data))

#to verify that the response data is a dictionary

<class 'dict'>

data

{'message': 'success',
 'people': [{'name': 'Jasmin Moghbeli', 'craft': 'ISS'},
  {'name': 'Andreas Mogensen', 'craft': 'ISS'},
  {'name': 'Satoshi Furukawa', 'craft': 'ISS'},
  {'name': 'Konstantin Borisov', 'craft': 'ISS'},
  {'name': 'Oleg Kononenko', 'craft': 'ISS'},
  {'name': 'Nikolai Chub', 'craft': 'ISS'},
  {'name': "Loral O'Hara", 'craft': 'ISS'}],
 'number': 7}

Finding the number and names of astronaunts:

data.values()

dict_values(['success', [{'name': 'Jasmin Moghbeli', 'craft': 'ISS'}, {'name': 'Andreas Mogensen', 'craft': 'ISS'}, {'name': 'Satoshi Furukawa', 'craft': 'ISS'}, {'name': 'Konstantin Borisov', 'craft': 'ISS'}, {'name': 'Oleg Kononenko', 'craft': 'ISS'}, {'name': 'Nikolai Chub', 'craft': 'ISS'}, {'name': "Loral O'Hara", 'craft': 'ISS'}], 7])

#how many people are in space?

print(data['number'])

7

#who are these people

print(data['people'])

[{'name': 'Jasmin Moghbeli', 'craft': 'ISS'}, {'name': 'Andreas Mogensen', 'craft': 'ISS'}, {'name': 'Satoshi Furukawa', 'craft': 'ISS'}, {'name': 'Konstantin Borisov', 'craft': 'ISS'}, {'name': 'Oleg Kononenko', 'craft': 'ISS'}, {'name': 'Nikolai Chub', 'craft': 'ISS'}, {'name': "Loral O'Hara", 'craft': 'ISS'}]

#returning the names of these astronaunts

people_in_space = data['people']
for ast in people_in_space:
    print(ast['name'])

Jasmin Moghbeli
Andreas Mogensen
Satoshi Furukawa
Konstantin Borisov
Oleg Kononenko
Nikolai Chub
Loral O'Hara

Converting the JSON data from API to dataframe:

Many APIs return data in JSON format. We need to convert this JSON file into a dataframe that can be easily analyzed.

Steps:

Use the request library to make the https requests to the API endpoint and retrieve the data. The API key, if required, needs to be included in the request headers

Once you have obtained the data, you can push it in a pandas df to analyze and process it.

Way 1

import requests
import pandas as pd

response = requests.get('http://api.open-notify.org/astros.json')

data = response.json()

df = pd.DataFrame(data)

df

message	people	number
0	success	{'name': 'Jasmin Moghbeli', 'craft': 'ISS'}	7
1	success	{'name': 'Andreas Mogensen', 'craft': 'ISS'}	7
2	success	{'name': 'Satoshi Furukawa', 'craft': 'ISS'}	7
3	success	{'name': 'Konstantin Borisov', 'craft': 'ISS'}	7
4	success	{'name': 'Oleg Kononenko', 'craft': 'ISS'}	7
5	success	{'name': 'Nikolai Chub', 'craft': 'ISS'}	7
6	success	{'name': 'Loral O'Hara', 'craft': 'ISS'}	7

#To remove the message and number columns

astronauts = pd.DataFrame(data['people'])
astronauts

name	craft
0	Jasmin Moghbeli	ISS
1	Andreas Mogensen	ISS
2	Satoshi Furukawa	ISS
3	Konstantin Borisov	ISS
4	Oleg Kononenko	ISS
5	Nikolai Chub	ISS
6	Loral O'Hara	ISS

Way 2
Using pd.json_normalize(). The json_normalize function in pandas is used to normalize semi-structures JSON data into a flat table.

response = requests.get('http://api.open-notify.org/astros.json')

data = response.json()

df = pd.json_normalize(data, record_path)
df

message	people	number
0	success	[{'name': 'Jasmin Moghbeli', 'craft': 'ISS'}, ...	7

#It didn't come out as expected. We want the results to be like that of way 1

response = requests.get('http://api.open-notify.org/astros.json')

data = response.json()

df = pd.json_normalize(data, record_path=['people'])
df


name	craft
0	Jasmin Moghbeli	ISS
1	Andreas Mogensen	ISS
2	Satoshi Furukawa	ISS
3	Konstantin Borisov	ISS
4	Oleg Kononenko	ISS
5	Nikolai Chub	ISS
6	Loral O'Hara	ISS

Way 3

df = pd.read_json('http://api.open-notify.org/astros.json')
df

message	people	number
0	success	{'name': 'Jasmin Moghbeli', 'craft': 'ISS'}	7
1	success	{'name': 'Andreas Mogensen', 'craft': 'ISS'}	7
2	success	{'name': 'Satoshi Furukawa', 'craft': 'ISS'}	7
3	success	{'name': 'Konstantin Borisov', 'craft': 'ISS'}	7
4	success	{'name': 'Oleg Kononenko', 'craft': 'ISS'}	7
5	success	{'name': 'Nikolai Chub', 'craft': 'ISS'}	7
6	success	{'name': 'Loral O'Hara', 'craft': 'ISS'}	7

#Again we are only intrested in the people column


astronauts = pd.json_normalize(df['people'])
astronauts

name	craft
0	Jasmin Moghbeli	ISS
1	Andreas Mogensen	ISS
2	Satoshi Furukawa	ISS
3	Konstantin Borisov	ISS
4	Oleg Kononenko	ISS
5	Nikolai Chub	ISS
6	Loral O'Hara	ISS

WORKING WITH JSON
Convertng python objects to json and vice versa using dumps() and loads()
Saving the data to json files and vice versa using dump() and load()
Python objects and json
dumps() and loads()
We can convert lists, tuples, and dictionaries (python objects) to JSON strings and convert JSON strings to lists and dictionaries.

json.dumps(python_object): converts python objects to json strings

json.loads(json_string): converts json string to python object

<class 'list'>

#converting python object to json string

char_string = json.dumps(char)
print(type(char_string))

#converting json string to python objects
char_object = json.loads(char_string)

print(type(char_object))

<class 'list'>

Creating, and reading JSON files:
dump() and load()
The json module has two main methods for doing this

json.dump(data, file_object): writes data into a json file format
json.load(file_object): for reading a json file

fast_food_franchise = {
    'Subway': 24722,
    'McDonalds': 14098,
    'Starbucks': 10821,
    'Pizza Hut': 34599
}

print(type(fast_food_franchise))

<class 'dict'>

#writing the data in  the dictionary to a file

import json

file_name = 'my_fast_food.json'

with open(file_name, 'w') as f:
    json.dump(fast_food_franchise, f)

f = open('my_fast_food.json', 'r')
data = f.read()

print(data)
print(type(data))
f.close()

{"Subway": 24722, "McDonalds": 14098, "Starbucks": 10821, "Pizza Hut": 34599}
<class 'str'>

#reading the data from the json file

file = 'my_fast_food.json'

with open(file, 'r') as f:
    data = json.load(f)

print(data)
print(type(data))

{'Subway': 24722, 'McDonalds': 14098, 'Starbucks': 10821, 'Pizza Hut': 34599}
<class 'dict'>

Extracting crypto data using Coingecko API:
Root_url = "https://api.coingecko.com/api/v3"

This is the link to the public API documentation.

Coingecko was founded in 2014 in order to democratize the access of crypto data and empower users with actionable insights.

API End points:

Ping: /ping
Coin list: /coin/list
Coin market: /coins/markets
Coin history: /coins/{id}/history
Coin market chart: coins/{id}/market_chart

Endpoint Ping:
import requests

root_url = "https://api.coingecko.com/api/v3"
endpoint = "/ping"

response =requests.get(root_url+endpoint)

response.status_code

200

response.headers

{'Date': 'Fri, 10 May 2024 15:24:16 GMT', 'Content-Type': 'application/json; charset=utf-8', 'Transfer-Encoding': 'chunked', 'Connection': 'keep-alive', 'x-frame-options': 'SAMEORIGIN', 'x-xss-protection': '0', 'x-content-type-options': 'nosniff', 'x-download-options': 'noopen', ...}

print(response.headers['Content-Type'])

print(response.text)

application/json; charset=utf-8
{"gecko_says":"(V3) To the Moon!"}

Endpoint coin list:
Use this to obtain all the coins id in order to make API calls.

import requests

endpoint = '/coins/list'

response = requests.get(root_url+endpoint)

response

<Response [200]>

#to retrieve the coins list

response.json()[:5]

[{'id': '01coin', 'symbol': 'zoc', 'name': '01coin'},
 {'id': '0chain', 'symbol': 'zcn', 'name': 'Zus'},
 {'id': '0-knowledge-network', 'symbol': '0kn', 'name': '0 Knowledge Network'},
 {'id': '0-mee', 'symbol': 'ome', 'name': 'O-MEE'},
 {'id': '0vix-protocol', 'symbol': 'vix', 'name': '0VIX Protocol'}]

#converting to a dataframe

import pandas as pd

data = response.json()

df = pd.DataFrame(data) #You can also use df = pd.read_json(root_url+endpoint)
df.head()

id	symbol	name
0	01coin	zoc	01coin
1	0chain	zcn	Zus
2	0-knowledge-network	0kn	0 Knowledge Network
3	0-mee	ome	O-MEE
4	0vix-protocol	vix	0VIX Protocol

df.shape
(14164, 3)

#to retrieve data for btc, eth and doge coins

df.loc[(df.symbol=='btc') | (df.symbol=='eth') | (df.symbol=='doge')]

id	symbol	name
1383	batcat	btc	batcat
1580	binance-peg-dogecoin	doge	Binance-Peg Dogecoin
1646	bitcoin	btc	Bitcoin
1762	blackrocktradingcurrency	btc	BlackrockTradingCurrency
2106	bridged-binance-peg-ethereum-opbnb	eth	Bridged Binance-Peg Ethereum (opBNB)
2166	bridged-wrapped-ether-starkgate	eth	Bridged Ether (StarkGate)
3817	dogecoin	doge	Dogecoin
3852	doge-on-pulsechain	doge	Doge on Pulsechain
4463	ethereum	eth	Ethereum

Endpoint coin markets:
Use this to obtain all the coins market data (price, market cap, volume)

import requests

endpoint = '/coins/markets'

parameters = {'vs_currency': 'usd', 'ids':'bitcoin, dogecoin, ethereum'}

response = requests.get(root_url+endpoint, params=parameters)
response

<Response [200]>

response.json()

[{'id': 'bitcoin',
  'symbol': 'btc',
  'name': 'Bitcoin',
  'image': 'https://assets.coingecko.com/coins/images/1/large/bitcoin.png?1696501400',
  'current_price': 60990,
  'market_cap': 1200655692518,
  'market_cap_rank': 1,
  'fully_diluted_valuation': 1280116095055,
  'total_volume': 27674490307,
  'high_24h': 63458,
  'low_24h': 60890,
  'price_change_24h': -1089.371358712844,
  'price_change_percentage_24h': -1.75479, ...}]

#converting to a dataframe

df = pd.json_normalize(response.json())
df.head()

id	symbol	name	image	current_price	market_cap	market_cap_rank	fully_diluted_valuation	total_volume	high_24h	...	ath_change_percentage	ath_date	atl	atl_change_percentage	atl_date	roi	last_updated	roi.times	roi.currency	roi.percentage
0	bitcoin	btc	Bitcoin	https://assets.coingecko.com/coins/images/1/la...	60990.000000	1200655692518	1	1280116095055	27674490307	63458.000000	...	-17.33993	2024-03-14T07:10:36.635Z	67.810000	89787.52759	2013-07-06T00:00:00.000Z	NaN	2024-05-10T15:41:53.824Z	NaN	NaN	NaN
1	ethereum	eth	Ethereum	https://assets.coingecko.com/coins/images/279/...	2925.560000	351380884466	2	351380884466	11272288058	3058.610000	...	-40.03879	2021-11-10T14:24:19.604Z	0.432979	675467.42706	2015-10-20T00:00:00.000Z	NaN	2024-05-10T15:41:32.509Z	63.149047	btc	6314.904712
2	dogecoin	doge	Dogecoin	https://assets.coingecko.com/coins/images/5/la...	0.145037	20912035222	10	20912114964	1066283107	0.153748	...	-80.18560	2021-05-08T05:08:23.458Z	0.000087	166702.68897	2015-05-06T00:00:00.000Z	NaN	2024-05-10T15:42:23.036Z	NaN	NaN	NaN

Endpoint coins history:
Get historical data (name, price, market, stats) at a given date for a coin

#retrieve today's date
from datetime import date

today = date.today().strftime('%d-%m-%Y')

print('Today: ', today)

Today:  10-05-2024

import requests

uid = 'bitcoin'

root_url = 'https://api.coingecko.com/api/v3'
endpoint = f'/coins/{uid}/history' #don't forget the 'f' string, it is crucial for the {uid} value to be collected
parameter = {'date': today}

response = requests.get(root_url+endpoint, params = parameter)

response

<Response [200]>

data = response.json()
data

{'id': 'bitcoin',
 'symbol': 'btc',
 'name': 'Bitcoin',
 'localization': {'en': 'Bitcoin',
  'de': 'Bitcoin',
  'es': 'Bitcoin',
  'fr': 'Bitcoin',
  'it': 'Bitcoin',
  'pl': 'Bitcoin',
  'ro': 'Bitcoin',
  'hu': 'Bitcoin',
  'nl': 'Bitcoin',
  'pt': 'Bitcoin'
  '...': '...'}

#storing the data in a dataframe

url = f'https://api.coingecko.com/api/v3/coins/bitcoin/history?date={today}'

df = pd.read_json(url)
df.head()

id	symbol	name	localization	image	market_data	community_data	developer_data	public_interest_stats
en	bitcoin	btc	Bitcoin	Bitcoin	NaN	NaN	NaN	NaN	NaN
de	bitcoin	btc	Bitcoin	Bitcoin	NaN	NaN	NaN	NaN	NaN
es	bitcoin	btc	Bitcoin	Bitcoin	NaN	NaN	NaN	NaN	NaN
fr	bitcoin	btc	Bitcoin	Bitcoin	NaN	NaN	NaN	NaN	NaN
it	bitcoin	btc	Bitcoin	Bitcoin	NaN	NaN	NaN	NaN	NaN

The output is not as expected wheen we compare this dataframe with the dictioanry form output in the code block above. Let's fix this.

#saving the data in a json file
file_name = f'bitcoin_history_{today}.json'

with open(file_name, 'w') as f:
    json.dump(data, f)

#lets have a look at the the keys of our data

data.keys()

dict_keys(['id', 'symbol', 'name', 'localization', 'image', 'market_data', 'community_data', 'developer_data', 'public_interest_stats'])

#retrieving market data

market_data = data['market_data']
print(market_data)

{'current_price': {'aed': 231944.8075909958, 'ars': 55729416.177562416, 'aud': 95405.78887443029, 'bch': 138.67987229341847, 'bdt': 6934445.955824399, 'bhd': 23807.337921547267, 'bmd': 63148.599943097026, 'bnb': 105.8682823386594, 'brl': 324729.0454873876, 'btc': 1.0, ...,}

df = pd.DataFrame(market_data)
df.head()

current_price	market_cap	total_volume
aed	2.319448e+05	4.557865e+12	9.490196e+10
ars	5.572942e+07	1.095119e+15	2.280211e+13
aud	9.540579e+04	1.874785e+12	3.903600e+10
bch	1.386799e+02	2.728693e+09	5.674191e+07
bdt	6.934446e+06	1.362663e+14	2.837281e+12

df.shape
(62, 3)

#to change the indexing of the data

df = df.reset_index()
df.head()

index	current_price	market_cap	total_volume
0	aed	2.319448e+05	4.557865e+12	9.490196e+10
1	ars	5.572942e+07	1.095119e+15	2.280211e+13
2	aud	9.540579e+04	1.874785e+12	3.903600e+10
3	bch	1.386799e+02	2.728693e+09	5.674191e+07
4	bdt	6.934446e+06	1.362663e+14	2.837281e+12

#renaming the index column
df = df.rename(columns={'index': 'symbol'})
df.head()

symbol	current_price	market_cap	total_volume
0	aed	2.319448e+05	4.557865e+12	9.490196e+10
1	ars	5.572942e+07	1.095119e+15	2.280211e+13
2	aud	9.540579e+04	1.874785e+12	3.903600e+10
3	bch	1.386799e+02	2.728693e+09	5.674191e+07
4	bdt	6.934446e+06	1.362663e+14	2.837281e+12

Endpoint coins/{id}/market_chart:
Gets historical market data including price, market cap, and 24hour volume(granularity auto)

Data granularity is automatic (and cannot be adjusted)
1 day from current time = 5 minute interval data
1-90 days from current time = hourly data
Above 90 days from current time = dail data (00:00 UTC)

import requests

uid = 'bitcoin'

root_url = 'https://api.coingecko.com/api/v3'
endpoint = f'/coins/{uid}/market_chart'
parameters = {'vs_currency': 'usd', 'days': '1'}

response = requests.get(root_url+endpoint, params =parameters)
response.status_code

200

response.json()

{'prices': [[1715272244520, 62551.858647265195],
  [1715272568154, 62356.68665826855],
  [1715272863568, 62397.987866653966],
  [1715273159016, 62412.76416880095],
  [1715273397500, 62114.61136883142],
  [1715273797489, 62014.73106993498],
  [1715274090122, 61862.857877488736],
  [1715274331334, 61840.93024544764],
  [1715274716866, 61954.810869332854],
  [1715274942866, 61946.13328148551],
  [1715275231864, 61837.9581117068],
  [1715275538551, 61932.42274598506],
  [..., ...],}

data = response.json()
data.keys()

dict_keys(['prices', 'market_caps', 'total_volumes'])

#retrieves the first 5 prices from the data
data['prices'][:5]

[[1715272244520, 62551.858647265195],
 [1715272568154, 62356.68665826855],
 [1715272863568, 62397.987866653966],
 [1715273159016, 62412.76416880095],
 [1715273397500, 62114.61136883142]]

#retrieves the first 5 market caps
data['market_caps'][:5]

[[1715272244520, 1232022158538.839],
 [1715272568154, 1232022158538.839],
 [1715272863568, 1232022158538.839],
 [1715273159016, 1228991517797.471],
 [1715273397500, 1228991517797.471]]

#creating a dataframe

df = pd.DataFrame(data)
df.head()

prices	market_caps	total_volumes
0	[1715272244520, 62551.858647265195]	[1715272244520, 1232022158538.839]	[1715272244520, 25463351354.988976]
1	[1715272568154, 62356.68665826855]	[1715272568154, 1232022158538.839]	[1715272568154, 26295449119.15045]
2	[1715272863568, 62397.987866653966]	[1715272863568, 1232022158538.839]	[1715272863568, 19100263308.444996]
3	[1715273159016, 62412.76416880095]	[1715273159016, 1228991517797.471]	[1715273159016, 14091230914.084883]
4	[1715273397500, 62114.61136883142]	[1715273397500, 1228991517797.471]	[1715273397500, 26486573377.911514]

#notice that for each of the columns we have a timestamp attached in each list
#we need to extract this

#to see what it looks like
df['prices'].str[0]

0      1715272244520
1      1715272568154
2      1715272863568
3      1715273159016
4      1715273397500
           ...      
284    1715357499125
285    1715357743095
286    1715358068338
287    1715358332063
288    1715358639000
Name: prices, Length: 289, dtype: int64

#adding a timestamp column
#str[0] extracts the first character from each price string in the prices column

df['timestamp'] = df['prices'].str[0]
df.head()

prices	market_caps	total_volumes	timestamp
0	[1715272244520, 62551.858647265195]	[1715272244520, 1232022158538.839]	[1715272244520, 25463351354.988976]	1715272244520
1	[1715272568154, 62356.68665826855]	[1715272568154, 1232022158538.839]	[1715272568154, 26295449119.15045]	1715272568154
2	[1715272863568, 62397.987866653966]	[1715272863568, 1232022158538.839]	[1715272863568, 19100263308.444996]	1715272863568
3	[1715273159016, 62412.76416880095]	[1715273159016, 1228991517797.471]	[1715273159016, 14091230914.084883]	1715273159016
4	[1715273397500, 62114.61136883142]	[1715273397500, 1228991517797.471]	[1715273397500, 26486573377.911514]	1715273397500

#lets further simplify the table

df['prices'] = df['prices'].str[1]
df['market_caps'] = df['market_caps'].str[1]
df['total_volumes'] = df['total_volumes'].str[1]

df.head()

prices	market_caps	total_volumes	timestamp
0	62551.858647	1.232022e+12	2.546335e+10	1715272244520
1	62356.686658	1.232022e+12	2.629545e+10	1715272568154
2	62397.987867	1.232022e+12	1.910026e+10	1715272863568
3	62412.764169	1.228992e+12	1.409123e+10	1715273159016
4	62114.611369	1.228992e+12	2.648657e+10	1715273397500

#Rearranging the dataframe

df = df[['timestamp', 'prices', 'market_caps', 'total_volumes']]
df

timestamp	prices	market_caps	total_volumes
0	1715272244520	62551.858647	1.232022e+12	2.546335e+10
1	1715272568154	62356.686658	1.232022e+12	2.629545e+10
2	1715272863568	62397.987867	1.232022e+12	1.910026e+10
3	1715273159016	62412.764169	1.228992e+12	1.409123e+10
4	1715273397500	62114.611369	1.228992e+12	2.648657e+10
...	...	...	...	...
284	1715357499125	60972.976145	1.194620e+12	2.857475e+10
285	1715357743095	61096.795045	1.194620e+12	2.865068e+10
289 rows Ã— 4 columns

#to obtain more information on the the dataframe

df.describe()

timestamp	prices	market_caps	total_volumes
count	2.890000e+02	289.000000	2.890000e+02	2.890000e+02
mean	1.715315e+12	62639.123016	1.233941e+12	2.461590e+10
std	2.506857e+07	568.282567	1.092167e+10	2.514742e+09
min	1.715272e+12	60704.730267	1.194620e+12	1.265039e+10
25%	1.715294e+12	62458.702511	1.230868e+12	2.396410e+10
50%	1.715315e+12	62853.829094	1.237992e+12	2.553595e+10
75%	1.715337e+12	62973.442738	1.240326e+12	2.614731e+10
max	1.715359e+12	63457.872232	1.248677e+12	2.865068e+10

df.info()

<class 'pandas.core.frame.DataFrame'>
RangeIndex: 289 entries, 0 to 288
Data columns (total 4 columns):
 #   Column         Non-Null Count  Dtype  
---  ------         --------------  -----  
 0   timestamp      289 non-null    int64  
 1   prices         289 non-null    float64
 2   market_caps    289 non-null    float64
 3   total_volumes  289 non-null    float64
dtypes: float64(3), int64(1)
memory usage: 9.2 KB

#the timestamp column is in integer instead of datetime data type
pd.to_datetime(df['timestamp'])

0     1970-01-01 00:28:35.272244520
1     1970-01-01 00:28:35.272568154
2     1970-01-01 00:28:35.272863568
3     1970-01-01 00:28:35.273159016
4     1970-01-01 00:28:35.273397500
                   ...             
284   1970-01-01 00:28:35.357499125
285   1970-01-01 00:28:35.357743095

#we can see that the unit for the output is in nano seconds
#converting to microseconds

pd.to_datetime(df['timestamp'], unit = 'ms')

0     2024-05-09 16:30:44.520
1     2024-05-09 16:36:08.154
2     2024-05-09 16:41:03.568
3     2024-05-09 16:45:59.016
4     2024-05-09 16:49:57.500
                ...          
284   2024-05-10 16:11:39.125
285   2024-05-10 16:15:43.095

#this is good to go, lets replace the timestamp column

df['timestamp'] = pd.to_datetime(df['timestamp'], unit = 'ms')
df.info()

<class 'pandas.core.frame.DataFrame'>
RangeIndex: 289 entries, 0 to 288
Data columns (total 4 columns):
 #   Column         Non-Null Count  Dtype         
---  ------         --------------  -----         
 0   timestamp      289 non-null    datetime64[ns]
 1   prices         289 non-null    float64       
 2   market_caps    289 non-null    float64       
 3   total_volumes  289 non-null    float64       
dtypes: datetime64[ns](1), float64(3)
memory usage: 9.2 KB

df.head()

timestamp	prices	market_caps	total_volumes
0	2024-05-09 16:30:44.520	62551.858647	1.232022e+12	2.546335e+10
1	2024-05-09 16:36:08.154	62356.686658	1.232022e+12	2.629545e+10
2	2024-05-09 16:41:03.568	62397.987867	1.232022e+12	1.910026e+10
3	2024-05-09 16:45:59.016	62412.764169	1.228992e+12	1.409123e+10
4	2024-05-09 16:49:57.500	62114.611369	1.228992e+12	2.648657e+10

df.describe()

prices	market_caps	total_volumes
count	289.000000	2.890000e+02	2.890000e+02
mean	62639.123016	1.233941e+12	2.461590e+10
std	568.282567	1.092167e+10	2.514742e+09
min	60704.730267	1.194620e+12	1.265039e+10
25%	62458.702511	1.230868e+12	2.396410e+10
50%	62853.829094	1.237992e+12	2.553595e+10
75%	62973.442738	1.240326e+12	2.614731e+10
max	63457.872232	1.248677e+12	2.865068e+10



WORKING WITH DATABASES IN PYTHON
MYSQL DATABASE
Python is a popular choice for working with databases due to its flexibility and rich ecosystem of libraries. With Python, you can connect to a variety of databases, both relational and non-relational. Python has several libraries available to interact with databases. E.g, sqlite3, mysql-connector-python, etc.

SQLite Database

# How to connect with database in python
import db module
import sqlite3

# Establish connection between the python program and the db
con = sqlite3.connect(name_of_database)

# To execute mysql query and hold result, a cursor is required
cursor = con.cursor()

# Execute mysql query with the help of cursor object
cursor.execute(query)

cursor.executemany()

# Fetch the result from the cursor object in case of select query
cursor.fetchall()

cursor.fetchone()

cursor.fetchmany(n)

# Commit or rollback changes as required
con.commit()

con.rollback()

# Close resources and disconnect database
cursor.close()

con.close()
----------------------------------------

import sqlite3

con = sqlite3.connect('Data/hannah.db')

print('Connection established')

con.close()

Connection established

import sqlite3

try:
    con = sqlite3.connect('Data/hannah.db')
    print(con)
finally:
    con.close()
    print('Completed')

# Creating a database table

import sqlite3

try:
    con = sqlite3.connect('hannah.db')

    cursor = con.cursor()

    query = 'CREATE TABLE employ_ees(eno int(5) primary key,\
                                    ename varchar(10), eage int(3))'

    cursor.execute(query)

    print('Table created successfully!')
    con.commit()

except sqlite3.DatabaseError as e:
    if con:
        con.rollback()
        print('Problem occured: ', e)

finally:
    if cursor:
        cursor.close()
    if con:
        con.close()
    print('Completed!')

Table created successfully!
Completed!

# Adding new columns
try:
    con = sqlite3.connect('hannah.db')
    cursor = con.cursor()
    query = 'alter table employ_ees add column eincome double(10,2)'
    cursor.execute(query)

    print('Column added successfully!')
    con.commit()

except sqlite3.DatabaseError as e:
    if con:
        con.rollback()
        print('Problem occured: ', e)
finally:
    if cursor:
        cursor.close()
    if con:
        con.close()
    print('Done')

Column added successfully!
Done

# Inserting operation
try:
    con = sqlite3.connect('hannah.db')
    cursor = con.cursor()
    query = 'insert into employ_ees(eno, ename, eage, eincome)\
             values(1, "LMS", 23, 345.67)'
    cursor.execute(query)

    con.commit()
    print('Row inserted!')

except sqlite3.DatabaseError as e:
    if con:
        con.rollback()
        print('Problem occured: ', e)
finally:
    if cursor:
        cursor.close()
    if con:
        con.close()
    print('All done.')

Row inserted!
All done.

## To add more than one row of data

import sqlite3

try:
    con = sqlite3.connect('hannah.db')
    cursor = con.cursor()
    query = 'insert into employ_ees(eno, ename, eage, eincome)\
            values(?,?,?,?)'
    records = [(3, 'ben', 23, 45.67),(4, 'ann', 56, 7890.8)]

    cursor.executemany(query, records) #note the use of executemany here, since we're performing more than one action

    con.commit()
    print('Table updated')

except sqlite3.DatabaseError as e:
    if con:
        con.rollback()
        print('Problem occured: ', e)

finally:
    if cursor:
        cursor.close()
    if con:
        con.close()
    print('Done')

Table updated
Done

# Read operation
try:
    con = sqlite3.connect('hannah.db')
    cursor = con.cursor()
    query = 'select * from employ_ees'

    cursor.execute(query)

    data = cursor.fetchall()

    for row in data:
        print('Eno: {}, Ename: {}, Eage: {}, Eincome: {}'.format(row[0], row[1], row[2], row[3]))

except sqlite3.DatabaseError as e:
    if con:
        con.rollback()
        print('Problem occured: ', e)
finally:
    if cursor:
        cursor.close()  #close the cursor first then the connection
    if con:
        con.close()
    print('All done!')

Eno: 1, Ename: LMS, Eage: 23, Eincome: 345.67
Eno: 3, Ename: ben, Eage: 23, Eincome: 45.67
Eno: 4, Ename: ann, Eage: 56, Eincome: 7890.8
All done!

# Update operation
try:
    con = sqlite3.connect('hannah.db')
    cursor = con.cursor()

    query = 'UPDATE employ_ees SET eage=eage+1 WHERE ename = "LMS"'

    cursor.execute(query)
    con.commit()

except sqlite3.DatabaseError as e:
    if con:
        con.rollback()
        print('Problem occured: ', e)
finally:
    if cursor:
        cursor.close()
    if con:
        con.close()
    print('Done!')

Done!

# Delete operation
try:
    con = sqlite3.connect('hannah.db')
    cursor = con.cursor()
    age = input('Enter age: ')

    query = 'DELETE FROM employ_ees WHERE eage ={}'.format(age)

    cursor.execute(query)

    con.commit()
    print('Delete completed!')

except sqlite3.DatabaseError as e:
    if con:
        con.rollback()
        print('Problem occured: ', e)

finally:
    if cursor:
        cursor.close()
    if con:
        con.close()
    print('Done')

Enter age: 34
Delete completed!
Done

# Reading the database to pandas
import pandas as pd
from sqlalchemy.engine import create_engine

#Using sqlalchemy connectable
engine = create_engine('sqlite:///Data/database.sqlite')

df = pd.read_sql_table('Salaries', engine)
df.head()

Id	EmployeeName	JobTitle	BasePay	OvertimePay	OtherPay	Benefits	TotalPay	TotalPayBenefits	Year	Notes	Agency	Status
0	1	NATHANIEL FORD	GENERAL MANAGER-METROPOLITAN TRANSIT AUTHORITY	167411.18	0	400184.25		567595.43	567595.43	2011		San Francisco	
1	2	GARY JIMENEZ	CAPTAIN III (POLICE DEPARTMENT)	155966.02	245131.88	137811.38		538909.28	538909.28	2011		San Francisco	
2	3	ALBERT PARDINI	CAPTAIN III (POLICE DEPARTMENT)	212739.13	106088.18	16452.6		335279.91	335279.91	2011		San Francisco	
3	4	CHRISTOPHER CHONG	WIRE ROPE CABLE MAINTENANCE MECHANIC	77916	56120.71	198306.9		332343.61	332343.61	2011		San Francisco	
4	5	PATRICK GARDNER	DEPUTY CHIEF OF DEPARTMENT,(FIRE DEPARTMENT)	134401.6	9737	182234.59		326373.19	326373.19	2011		San Francisco
	

df.info()

<class 'pandas.core.frame.DataFrame'>
RangeIndex: 148654 entries, 0 to 148653
Data columns (total 13 columns):
 #   Column            Non-Null Count   Dtype  
---  ------            --------------   -----  
 0   Id                148654 non-null  int64  
 1   EmployeeName      148654 non-null  object 
 2   JobTitle          148654 non-null  object 
 3   BasePay           148654 non-null  object 
 4   OvertimePay       148654 non-null  object 
 5   OtherPay          148654 non-null  object 
 6   Benefits          148654 non-null  object 
 7   TotalPay          148654 non-null  float64
 8   TotalPayBenefits  148654 non-null  float64
 9   Year              148654 non-null  int64  
 10  Notes             148654 non-null  object 
 11  Agency            148654 non-null  object 
 12  Status            148654 non-null  object 
dtypes: float64(2), int64(2), object(9)
memory usage: 14.7+ MB


MySQL
MySQLdb vs pymysql vs mysql.connector

#installing libraies

!pip install mysql.connector

!pip install pymysql

#Connecting with a database in python
import database module
import pymysql as pm

OR

import mysql.connector as pm

#Establish connection between python program and db
con = pm.connect(host, database, user, password)

#To execute mysql query and hold result, cursor is required
cursor = con.cursor()

#Execute mysql query with the help of the cursor object
cursor.execute(query)

cursor.executemany()

#Fetch results from cursor object in case of a select query
cursor.fetchone()

cursor.fetchall()

cursor.fetchmany(n)

#Commit or rollback changes based on your requirement
con.commit()

con.rollback()

Close resources and disconnect database
cursor.close()

con.close()

#Establishing a connection
import pymysql as pm

try:
    con = pm.connect(host='localhost', database='retail_sales',\
                     user='root', password='root') #insert your password here
    print(con)

finally:
    con.close()
    print('Done')

#note that the database name must exist in your own mysql for the code to work as expected.

<pymysql.connections.Connection object at 0x000001ED837916D0>
Done

#Creating database table
try:
    con = pm.connect(host='localhost', database = 'retail_sales',\
                    user = 'root', password = 'root')

    cursor = con.cursor()

    query = 'CREATE TABLE employees1(eno int(5) PRIMARY KEY,\
             ename varchar(10), eage int(3), eincome double(10,2),\
             FOREIGN KEY(eno) REFERENCES employees(eno))' #make sure you have a table called 'employees in your database'

    cursor.execute(query)

    print('Table created successfully')
    con.commit()

except pm.DatabaseError as e:
    if con:
        con.rollback()
        print('Problem occured: ', e)

finally:
    if cursor:
        cursor.close()
    if con:
        con.close()
    print('Done!')

Table created successfully
Done!

# Insert operation
import pymysql as pm
try:
    con = pm.connect(host='localhost', database = 'retail_sales',\
                    user = 'root', password = 'root')

    cursor = con.cursor()

    query = 'INSERT INTO employees1(eno, ename, eage, eincome)\
            values(%s,%s,%s,%s)' ##We used %s here

    records = [(3, 'ben', 23, 45.67),(4, 'ann', 56, 7890.8)]

    cursor.executemany(query, records)

    print('Table created successfully')
    con.commit()

except pm.DatabaseError as e:
    if con:
        con.rollback()
        print('Problem occured: ', e)

finally:
    if cursor:
        cursor.close()
    if con:
        con.close()
    print('Done!')

Problem occured:  (1452, 'Cannot add or update a child row: a foreign key constraint fails (`retail_sales`.`employees1`, CONSTRAINT `employees1_ibfk_1` FOREIGN KEY (`eno`) REFERENCES `employees` (`eno`))')
Done!

# Read operation
import pymysql as pm
try:
    con = pm.connect(host='localhost', database = 'retail_sales',\
                    user = 'root', password = 'root')

    cursor = con.cursor()

    query = 'SELECT * FROM employees1'


    cursor.execute(query)
    data = cursor.fetchall()

    for row in data:
        print('Eno: {}, Ename: {}, Eage: {}, Esalary: {}'\
              .format(row[0], row[1], row[2], row[3]))


except pm.DatabaseError as e:
    if con:
        con.rollback()
        print('Problem occured: ', e)

finally:
    if cursor:
        cursor.close()
    if con:
        con.close()
    print('Done!')

#Update operation
try:
    con = pm.connect(host='localhost', database = 'retail_sales',\
                    user = 'root', password = 'root')

    cursor = con.cursor()

    query = 'UPDATE employees1 SET eage=eage+1 WHERE ename = "ben"'


    cursor.execute(query)
    con.commit()


except pm.DatabaseError as e:
    if con:
        con.rollback()
        print('Problem occured: ', e)

finally:
    if cursor:
        cursor.close()
    if con:
        con.close()
    print('Done!')

Done!

#Delete operation
try:
    con = pm.connect(host='localhost', database = 'retail_sales',\
                    user = 'root', password = 'root')

    cursor = con.cursor()

    age = input('Enter a number: ')
    query = 'DELETE FROM employees1 WHERE eage="%s"'%(age)


    cursor.execute(query)
    con.commit()


except pm.DatabaseError as e:
    if con:
        con.rollback()
        print('Problem occured: ', e)

finally:
    if cursor:
        cursor.close()
    if con:
        con.close()
    print('Done!')

Enter a number: 56
Done!

SQLAlchemy ORM
ORM - Object Relational Mapper. It is a python library that simplifies interacting with relational databases. It acts as a bridge between the object-oriented world of python and the structured world of relational databases.

SETUP

Step 1: installing the modules
pip install Flask-SQLAlchemy

pip install Flask-Migrate

Step 2: create a flask app
from flask import Flask
app = Flask(name)

Step 3: import SQLAlchemy and Migrate module
from flask_sqlalchemy import SQLAlchemy

from flask_migrate import Migrate

Step 4: SQLAlchemy Configuration and pass the application into SQLAlchemy class
basedir = os.path.abspath(os.path.dirname(file))

path = 'sqlite:///'+os.path.join(basedir, 'data.sqlite')

app.config['SQLALCHEMY_DATABASE_URL'] = path app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app) Migrate(app, db)

Step 5: Create a model or table

Create a model class
Inherit from db.Model
Provide the table name
Add columns in the model
Create _init__and __repr__
class Box(db.Model):
    __tablename__ = 'boxes'
    id = db.Column(db.Integer, primary_key = True)
    name = db.Column(db.Text)
    mrp = db.Column(db.Integer)

    def __init__(self, name, mrp):
        self.name = name
        self.mrp = mrp

    def __repr__(self):
        return 'Box Name - {} and MRP- {}'.format(self.name, self.mrp)
Step 6: Run the following commands to migrate the database

set FLASK_APP=app.py

flask db init

flask db migrate -m 'My first DB migrate'

flask db upgrade

Basic CRUD Operations
Create or Insert Operation
box = Box(name = 'biscuit', price = 10) #creating an object

db.session.add(box)

db.session.commit()

Read operation
Box.query.all()

Update operation
box = Box.query.get(2)

box.name = 'aloo'

db.session.commit()

Delete Operation
box = Box.query.get(2)

db.session.delete(box)

db.session.commit()

Exploring Read Operation usiing filter_by
Syntax - MODEL_NAME.query.filter_by(MODEL_COLUMN_NAME='')

Getting all the rows if box name is "biscuit" from the database table
Box.query.filter_by(name='biscuit').all()

Getting only the first row if sabji name is 'biscuit'
Box.query.filter_by(name='biscuit').first()

Count of rows if box name is "biscuit"
Box.query.filter_by(name='biscuit').count()

Getting rows by id
Box.query.filter_by(id=2).first()

OR

Box.query.get(2)

Other powerful queries using filter
Note: filter_by is used for simple queries on the column names using regular kwargs like: User.filter_by(name="Joe")

The same can be accomplished with filter not using kwargs, but instead using operators (==, !=, >, <, etc.) which has been overloaded on the db.users,name object like thus: User.filter(User.name=='Ann')

Getting all the boxes with the name not equal to "biscuit" from the database table
Box.query.filter(Box.name != "biscuit").all()

LIKE
Box.query.filter(Box.name.like('%b%')).all()

IN
Box.query.filter(Box.name.in_(['biscuit', 'wine'])).all()

AND
Box.query.filter(and_Box.name=='biscuit', Box.price>10)).all()

OR
Box.query.filter(or_(Box.name=='biscuit', Box.price>10)).all()

Order By and JOIN
ORDER BY
Box.query.order_by(Box.name.desc()).all() #you can remove the "desc()" if not needed

Join
db.session.query(Box, Vendor).filter(Box.id==Vendor.sabji_id).all()






import mysql.connector

db = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="root",
    database="testdatabase"
    )

mycursor = db.cursor()

mycursor.execute("CREATE DATABASE testdatabase")



CONCISE FUNCTIONS
Concise functions look at a more concise way to create lists and other Python functions.

LIST COMPREHENSION
They offer a more concise way to create new lists in Python. They offer a one-line alternative to using traditional for loops and append statements.

#Here, we have a list of numbers. We want to check for thr numbers which
#even and then append those values to the nums list

nums = [34, 56, 77, 98, 66, 55, 33, 31, 12, 237]

evens = []

##Solution
for num in nums:
    if num%2 == 0:
        evens.append(num)
print(evens)

[34, 56, 98, 66, 12]

## List comprehension can do this in a better way

evens = [num for num in nums if num%2 == 0]

print(evens)

[34, 56, 98, 66, 12]

lst = [expression for i in sequence]

This says for every i in the sequence, apply the expression and add that expression value to the lst.

#example 1

lst = [a for a in 'PYTHON']

lst

['P', 'Y', 'T', 'H', 'O', 'N']

#example 2

lst = [i**2 for i in range(1,20) if i%2 != 0]
print(lst)


#Here, we are saying that for every i value in the sequence,
#if the i value is an odd number then square it and append to the lst list

#Typically the even numbers will be [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
#And when you square these, you'll see the output

[1, 9, 25, 49, 81, 121, 169, 225, 289, 361]

#example 3

heros = ['Black Widow', 'Hawkeye', 'Doctor Strange']

#extracting the first character of each name into a list

lst = [word[0] for word in heros]
lst

['B', 'H', 'D']

#example 4

string = 'The quick fox and the slow tortoise were friends a long time ago'

#convert each word into upper case 
#and count the number of characters in each word

lst = [[word.upper(), len(word)] for word in string]
print(lst)

[['T', 1], ['H', 1], ['E', 1], [' ', 1], ['Q', 1], ['U', 1], ['I', 1], ['C', 1], ['K', 1], [' ', 1], ['F', 1], ['O', 1], ['X', 1], [' ', 1], ['A', 1], ['N', 1], ['D', 1], [' ', 1], ['T', 1], ['H', 1], ['E', 1], [' ', 1], ['S', 1], ['L', 1], ['O', 1], ['W', 1], [' ', 1], ['T', 1], ['O', 1], ['R', 1], ['T', 1], ['O', 1], ['I', 1], ['S', 1], ['E', 1], [' ', 1], ['W', 1], ['E', 1], ['R', 1], ['E', 1], [' ', 1], ['F', 1], ['R', 1], ['I', 1], ['E', 1], ['N', 1], ['D', 1], ['S', 1], [' ', 1], ['A', 1], [' ', 1], ['L', 1], ['O', 1], ['N', 1], ['G', 1], [' ', 1], ['T', 1], ['I', 1], ['M', 1], ['E', 1], [' ', 1], ['A', 1], ['G', 1], ['O', 1]]

#the above capitalizes each letter but this is not what we desire
#to rectify this we use split to seoerate the words from each other 

lst = [[word.upper(), len(word)] for word in string.split(' ')]
lst

[['THE', 3],
 ['QUICK', 5],
 ['FOX', 3],
 ['AND', 3],
 ['THE', 3],
 ['SLOW', 4],
 ['TORTOISE', 8],
 ['WERE', 4],
 ['FRIENDS', 7],
 ['A', 1],
 ['LONG', 4],
 ['TIME', 4],
 ['AGO', 3]]

ANONYMOUS FUNCTIONS
AKA lambda functions. These are functions defined without a name using the lambda keyword. They are defined in a sinbgle line of code and can only contain one expression which repesents the function's body and return value.

Syntax: lambda arguments: expression

# normal function definition

def square(n):
    return n**2
print(square(5))

25

#using lambda

lambda_sq = lambda n: n**2

print(lambda_sq(5))

#using lambda with two arguments

prod = lambda a,b: a*b

print(prod(3,4))

12


#using lambda again and a concept from list comprehension

greater = lambda a,b: a if a>b else b

print(greater(345, 67849))

67849

filter()
A built-in python functions that allows you to efficiently process an iterable like a tuple, list or string and return a new iterator containing only the elements that meet a certain condition

Syntax: filter(function, sequence)

Problem: We have 10 numbers and we want to filter only the even numbers from that list.

#Using traditional means of problem solving

def isEven(x):
    if x%2 == 0:
        return True
    else:
        return False

lst = [0,1,2,3,4,5,6,7,8,9,10]

filtered_list = filter(isEven, lst)

print(filtered_list)
print(type(filtered_list))

<filter object at 0x000001ADBA1D2790>
<class 'filter'>

#from the above we can see the result and type of the results, so we need to convert the results to a list

filtered_list = list(filter(isEven, lst))

print(filtered_list)
print(type(filtered_list))

[0, 2, 4, 6, 8, 10]
<class 'list'>

#Using concise problem solving

lst = [0,1,2,3,4,5,6,7,8,9,10]

filtered_list = list(filter(lambda x: x%2 == 0, lst))

print(filtered_list)

[0, 2, 4, 6, 8, 10]

map()
Built-in python function used to apply a function to all elements of an iterable and return a new iterator containing the results

Synatx: map(function, sequence)

#EXAMPLE 1
#traditional problem solving

def double(x):
    return 2*x

lst = [1,2,4,5,6]

new_list = list(map(double, lst))
new_list

[2, 4, 8, 10, 12]

#concise problem solving

new_list = list(map(lambda x: 2*x, lst))
new_list

[2, 4, 8, 10, 12]

#EXAMPLE 2

#multiplying two lists element wise
list1 = [1,2,3]
list2 = [4,5,6]

new_list = list(map(lambda x,y: x*y, list1, list2))
new_list

[4, 10, 18]

reduce()
This function is used to reduce a sequence of elements nto a single element by applying the specified function

It is present in the functools module.

Syntax

from functools import *

reduce(function, sequence)

from functools import *

lst = [1,2,3,4,5,6,7,8,9]

reduced_list = reduce(lambda x,y: x+y, lst)

reduced_list

45



OBJECT-ORIENTED PROGRAMMING (OOP)
Object-Oriented Programming (OOP) is a way of writing programs by creating things called objects. These objects can hold data and also perform actions. Each object has two main parts:
- Attributes: These are the features of the object (like the color of a car or the model of a phone).
- Methods: These are the actions the object can perform (like a car driving or a phone making a call).

Why Use OOP?
OOP makes it easier to organize and manage larger programs by:
- Keeping related data and actions together.
- Reusing code without repeating yourself.
- Making programs more structured and easier to understand.

OOP mirrors the way the world works.

Code is organized into self contained parts/objects - like the objects around you now

By structuring code as objects we can change one part of it and it won't affect the others.

A class is a definition or blueprint from which objects are created. E.g The blueprint of a car tells us what the car has or is made of - body, wheels, engine, and what a car does (functionalities) - drive(), brake(), turn(). Now we can take this blueprint to build a car - which is now known as an object.

1. Class - blueprint of an object
class ClassName:

   - Variables(properties - to store data)      
   - Constructor - a special method      
   - Methods (behaviours)- (a way to update the properties - same thing as a function)

class MyFirstClass:
    '''This is my first class.'''
    pass

print(MyFirstClass)
print(MyFirstClass.__doc__)
help(MyFirstClass)

<class '__main__.MyFirstClass'>
This is my first class.
Help on class MyFirstClass in module __main__:

class MyFirstClass(builtins.object)
 |  This is my first class.
 |  
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Object creation AKA instantiation - i.e creating an instance of the object:

# synthax -> object_name = ClassName()

first_obj = MyFirstClass()

first_obj
<__main__.MyFirstClass at 0x1ab0ae336d0>

Variables and methods

class HelloWorld:
    '''This is my Hello World class'''
    
    class_variable = 'Variable'   #creating a variable 
    
    def display(self):   #creating a method called display()
        return('Method called')

# Accessing the variables and methods of a class

#first create an instance of the object with the class
second_object = HelloWorld()

#printing the variable
print(second_object.class_variable)

#using the method

second_object.display()

Variable
'Method called'

Constructors
A special method
It gets called automatically at object intialization/instantiation
It is used for intializing the variables (very important)
Returns None

Constructor with single variable

class HelloWorld:
    '''This is my Hello World class'''
    
    #creating the constructor
    def __init__(self):
        print('Constructor called')
    
    #creating the method
    def display(self):
        print('Hello World')

        
hello_object = HelloWorld()
print(hello_object)

hello_object.display()

Constructor called
<__main__.HelloWorld object at 0x000001AB0AE33940>
Hello World

Constructor with multiple parameters

'''
'self' is an instance variable that should be used in the constructor or method
Remember the constructor is automatically called when you create an instance of an object
'''

class Student:
    def __init__(self, name, rno, marks):  #a constructor with the instance variables
        self.name = name
        self.rno = rno
        self.marks = marks
    
    #creating a method
    def display(self):
        #print(self.name, self.rno, self.marks) OR
        
        print('Name: {}, Room_number: {}, Marks: {}'.format(self.name, self.rno, self.marks))

#testing
student1 = Student('Ann', 1, 98)
student1.display()
        
Name: Ann, Room_number: 1, Marks: 98

#using the __dict__ data descriptors

student1.__dict__

Types of variables (AKA properties)
A. Instance variable

- It is an object level variable
- The value of this variable varies from object to object, that is, they are only present for that one instance of an object

B. Static variable AKA class variable

- It is a class level variable
- These variables are the same for all objects

C. Local variable

- This is a method level variable - avaiable within a method

How to access the Instance variable

--> Inside a class: self.variable_name

--> Outside a class: object_name.variable_name

class Student:
    def __init__(self, name, rno, marks):
        self.name = name
        self.rno = rno
        self.marks = marks
    
    #creating a method
    def display(self):
        print(self.name, self.rno, self.marks) #accessing inside a class

#testing
student1 = Student('Ann', 1, 98)  #accessing outside a class
student1.display()

Ann 1 98

How to access the static variable

--> Inside a class: ClassName.variable_name OR self.variable_name

--> Outside a class: ClassName.variable_name OR object_name.variable_name

class Student:
    college = 'Stanford' #static variable
    
    def __init__(self, name, rno, marks):
        self.name = name
        self.rno = rno
        self.marks = marks
    
    def display(self):
        print(self.name, self.rno, self.marks)
        print(self.college)  #accessing the static variable inside a class

student2 = Student('Ann', 2, 98)
student3 = Student('John', 6, 76)

student2.display()

student3.display()

[ ]
class Student:
    college = 'Stanford' #static variable
    
    def __init__(self, name, rno, marks):
        self.name = name
        self.rno = rno
        self.marks = marks
    
    def display(self):
        print(self.name, self.rno, self.marks)
        print(self.college)  #accessing the static variable inside a class

student2 = Student('Ann', 2, 98)
student3 = Student('John', 6, 76)

student2.display()

student3.display()

Ann 2 98
Stanford
John 6 76
Stanford

# accessing the static variable outside the class

print(Student.college)  #using the ClassName
print(student2.college)  #using the object_name

Stanford
Stanford

#let us see if we can change this static variable

Student.college = 'ABCD'

student2.display()
student3.display()

Ann 2 98
ABCD
John 6 76
ABCD

Local variable

class Test:
    def m1(self):
        x = 10
        print(x)
    
    def m2(self):
        y = 20
        print(y)

test = Test()

test.m1()  # accessing the local variable using the object name
test.m2()

10
20

Types of methods (behaviours)
Instance method

Uses the self parameter which indicates that or points to an object instance
Instance variables are used with instance methods
Can be used to modify the instance state

class Pupil:
    school = 'NASA'
    
    def __init__(self, m1,m2,m3):
        self.m1 = m1
        self.m2 = m2
        self.m3 = m3
    
    #defining an instance method - you can see it uses the self parameter
    def avg(self):
        return(self.m1+self.m2+self.m3)/3

s1 = Pupil(34, 45, 67)

print(s1)

#calling the instance method requires that you specify the object name

print(s1.avg())

<__main__.Pupil object at 0x000001AB0B697490>
48.666666666666664

Class method

Uses the cls parameter which indicates that or points to the class and not the object instance when the method is called
Class(i.e static) variables are used with class methods

class Pupil:
    school = 'NASA'
    
    def __init__(self, m1,m2,m3):
        self.m1 = m1
        self.m2 = m2
        self.m3 = m3
    
    def avg(self):
        return(self.m1+self.m2+self.m3)/3
    
    #creating a class method using the @classmethod decorator
    
    @classmethod
    def getSchool(cls):
        return cls.school
                

s1 = Pupil(34, 45, 67)

print(s1)

#remember that the class method points to the class name hence we attach it to the object name
print(Pupil.getSchool())  

#We use Pupil (which is the class name) instead of the Object (s1) 
#because the getSchool method is attached to the class which in turn is conected to the object, 
#it is like a subset of the class Pupil

<__main__.Pupil object at 0x0000023FBD12BA00>
NASA

Static method

Uses neither the self or cls parameter
It is free to accept an arbitary number of other parameters
Cannot modify object or class state. It is only restricted to the data they can access

class Pupil:
    school = 'NASA'
    
    def __init__(self, m1,m2,m3):
        self.m1 = m1
        self.m2 = m2
        self.m3 = m3
    
    def avg(self):
        return(self.m1+self.m2+self.m3)/3
    
    #creating a class method using the @classmethod decorator
    
    @classmethod
    def getSchool(cls):
        return cls.school
    
    #usually kept blank
    @staticmethod
    def info():
        return('I am a Data scientist')
        
        
s1 = Pupil(34, 45, 67)


print(Pupil.info())

I am a Data scientist

Access Modifiers
Used to restrict the access to the variables and methods. Python uses the _ symbol to determine the acess control

Public

No symbol is used here
Members (data and functions of a class) defined as public will be accessible from any part of the program
This is the default state unless otherwise stated
Private

Uses a double underscore __ symbol before the data member of that class
Members of a class declared private are accessible within the class only
Most secure
Protected

Uses a single underscore _ symbol before the data member of that class
Members of a class declared protected are only accessible to a class derived from it.

class Boy:
    def __init__(self, name, age):
        
        #public data member
        self.name=name
        
        #private data member
        self.__age = age
    
    def display(self):
        print(self.name)

object_name = Boy('Sam', 298)

object_name.display()

#this prints just the name, the age is privately secured and therefore not accessible

Sam 298

Create a Bottle class with color and capacity properties

class Bottle:
    
    def __init__(self, color, capacity):
        self.color = color
        self.capacity = capacity
    
    def display(self):
        return('The color of the bottle is {} with a capacity of {}L'.format(self.color, self.capacity))

Mybottle = Bottle('Blue', 120)

Mybottle.display()

The color of the bottle is Blue with a capacity of 120L

Create a Human class with some properties and methods

class Human:
    state = 'Ebonyi'
    
    def __init__(self, gender, height, age, occupation):
        self.gender = gender
        self.height = height
        self.age = age
        self.occupation = occupation
    
    def show_details(self):
        return(self.gender, self.height, self.age, self.occupation)
    
    def getState(cls):
        return(cls.state)
    
    def update_age(self, age):
        self.age = age
        return 'Age updated successfully'

human_being = Human('Female', 1.65, 23, 'Data Analyst')
print(human_being)

<__main__.Human object at 0x0000023FBD21ACA0>

human_being.show_details()

('Female', 1.65, 23, 'Data Analyst')

human_being.getState()

'Ebonyi'

human_being.update_age(34)

'Age updated successfully'

human_being.show_details()

human_being.show_details()

('Female', 1.65, 34, 'Data Analyst')

Create a circle class and initialize it with radius. Make two methods getArea and getCircumference inside this class.

import math

class Circle:
    def __init__(self, radius):
        self.radius = radius
    
    def getArea(self):
        return (3.14*(self.radius)**2)
    
    def getCircumference(self):
        return (2*3.14*self.radius)

my_circle = Circle(4)

print(my_circle.getArea())
print(my_circle.getCircumference())

50.24
25.12

Create a Student class and initialize it with name and roll number. Make methods to :
Display - It should display all informations of the student.
setAge - It should assign age to student
setMarks - It should assign marks to the student.

class Student:
    
    age = 50
    marks = 100
    
    def __init__(self, name, rno):
        self.name = name
        self.rno = rno
        
    def display(self):
        return(self.name, self.rno)
    
    @classmethod
    def setAge(cls):
        return(cls.age)
    
    @classmethod
    def setMarks(cls):
        return(cls.marks)

students = Student(name='Jane', rno=21)

students.display()

#Student.setAge()

#students = Student.setMarks()

('Jane', 21)

Student.__dict__


Student.__dict__
mappingproxy({'__module__': '__main__',
              'age': 50,
              'marks': 100,
              '__init__': <function __main__.Student.__init__(self, name, rno)>,
              'display': <function __main__.Student.display(self)>,
              'setAge': <classmethod at 0x23fbd132550>,
              'setMarks': <classmethod at 0x23fbd132130>,
              '__dict__': <attribute '__dict__' of 'Student' objects>,
              '__weakref__': <attribute '__weakref__' of 'Student' objects>,
              '__doc__': None})

Create a Temprature class. Make two methods :
convertFahrenheit - It will take celsius and will print it into Fahrenheit.
convertCelsius - It will take Fahrenheit and will convert it into Celsius.

class Temperature:
    def __init__(self, x):
        self.x = x
          
    def convertCelsius(self):
        return ((self.x-32)*5/9)
    
    def convertFahrenheit(self):
        return (self.x*(9/5))+32

temp_check = Temperature(67)

print(temp_check.convertFahrenheit())
print(temp_check.convertCelsius())

152.60000000000002
19.444444444444443

Create a class Expenditure and initialize it with salary,savings, category , total expenditure.Make the following methods.

Add expenditure according to category .
Calculate total expenditure.
Calculate per day expenditure and a two months expenditure.

class Expenditure:
    
    def __init__(self,salary,savings):
        self.salary = salary
        self.savings = savings
        self.categories = {}   #intializes a dictionary
        self.total_expenditure = 0   #this value will be updated, hence it is intialized by setting it 0
    
    def category_expenditure(self, category, expenses): #this method takes two parameters
        
        #first, we check if the category exists and then add the amount entered to the expenditure for that category
        if category in self.categories:
            self.categories[category] += expenses
        
        #if it doesn't it adds the new category and the expense for that category
        else:
            self.categories[category] = expenses
        
        #When the conditional statement has been fulfilled, the amount is added to the total_expenditure and it is therefore updated
        self.total_expenditure += expenses
        
        return self.categories, self.total_expenditure
    
    #remember the total_expensiture is always updated therefore at anytime we have the total expenditure in that variable
    def cal_total_expenditure(self):
        return self.total_expenditure
    
    def daily_expenditure(self):
        days = 30
        return self.total_expenditure/days
    
    def monthly_expenditure(self, month):
        return self.total_expenditure*month

expenditure_tracker = Expenditure(salary = 5000, savings= 1000)

## Let me add some of the expenses I have made

expenditure_tracker.category_expenditure('food', 500)
expenditure_tracker.category_expenditure('shoes', 800)
expenditure_tracker.category_expenditure('mouse', 1500)
expenditure_tracker.category_expenditure('fan', 300)

({'food': 500, 'shoes': 800, 'mouse': 1500, 'fan': 300}, 3100)

#checking for total_expenditure so far

expenditure_tracker.cal_total_expenditure()

3100

#what is my daily expenditure like assuming that the total_expenditure is my total expenses for a month

expenditure_tracker.daily_expenditure()

103.33333333333333

#what will my expenditure be for the next two months

expenditure_tracker.monthly_expenditure(3)

9300


CONCEPTS OF OOP
Encapsulation: groups related functions and variables together = reduce complexity and increase reusability
Abstraction: hides the details and complexities and shows the essentail = reduces complexity and isolate the impact of changes in the code
Inheritance: eliminates redundant code
Polymorphism: refactor ugly switch/case statements.

Inheritance
It is the ability of one class to derive or inherit the properties from another class. It also has it's types.

It represents real world relationships
We don't have to write the same code again and again and we can add more features to a class without modifying it
1. Single inheritance
A single parent to child relationship

# What the code looks like without any inheritance

class A:
    def m1():
        pass
    def m2():
        pass

class B:
    def m1():
        pass
    def m2():
        pass
    def m3():
        pass
    def m4():
        pass

#Notice how we had to copy and paste all the methods from classA to ClassB, imagine we have these for a more complex code

# With inheritance

#This is the parent class
class A:
    def m1(self):
        print('Class A, method 1')
        
    def m2(self):
        print('Class A, method 2')

#the child inheriting from the first class       
class B(A):
    def m3(self):
        print('Class B, method 3')
    
    def m4(self):
        print('Class B, method 4')

#testing the concept

b = B()

b.m1()
b.m3()

Class A, method 1
Class B, method 3


2. Multilevel inheritance
A single parent, a child and a grandchild (as you know, from the child)

Parent -> Child1 -> grandchild

## What the code looks like without inheritance

class A:
    def m1():
        pass
    def m2():
        pass

class B:
    def m1():
        pass
    def m2():
        pass
    def m3():
        pass
    def m4():
        pass

class C:
    def m1():
        pass
    def m2():
        pass
    def m3():
        pass
    def m4():
        pass
    def m5():
        pass
    def m6():
        pass

#How multilevel inheritance solves this problem

#parent
class A:
    def m1(self):
        print('Class A, method 1')
    def m2(self):
        print('Class A, method 2')

#child 
class B(A):
    def m3(self):
        print('Class B, method 3')
    def m4(self):
        print('Class B, method 4')

#grandchild        
class C(B):
    def m5(self):
        print('Class C, method 5')
    def m6(self):
        print('Class C, method 6')

#testing the concept
b = B()
c = C()

print(b.m2())
print(c.m1())

#remember why we see 'None' in the output right? Yes. It's because we used print in the function call instead of return

Class A, method 2
None
Class A, method 1
None

3. Multiple inheritance
One child inheriting from two parents

#parent
class A:
    def m1(self):
        print('Class A, method 1')
    def m2(self):
        print('Class A, method 2')

#parent
class B:
    def m3(self):
        print('Class B, method 3')
    def m4(self):
        print('Class B, method 4')

#child
class C(A,B):
    def m5(self):
        print('Class C, method 5')
    def m6(self):
        print('Class C, method 6')

4. Hirerachical inheritance
Two children inheriting from a single parent

#keep in mind the last code without inheritance we wrote

#parent
class A:
    def m1(self):
        print('Class A, method 1')
    def m2(self):
        print('Class A, method 2')

#first child
class B(A):
    def m3(self):
        print('Class B, method 3')
    def m4(self):
        print('Class B, method 4')

#second child
class C(A):
    def m5(self):
        print('Class C, method 5')
    def m6(self):
        print('Class C, method 6')

c = C()

c.m2()

Class A, method 2

5. Hybrid inheritance
A combination of all the above types of inheritance.

#parent
class A:
    pass

#first child of A
class B(A):
    pass

#second child of A
class C(A):
    pass

#child benefiting from other children
class D(B, C):
    pass


#Class B and C share the same parent - hirerachical
#Class D has a direct relationship with the parent and the second child

Using super() to access the constructor and methods of the parent class

class A:
    def m1(self):
        print('Class A, method 1')
    def m2(self):
        print('Class A, method 2')

class B(A):
    def m3(self):
        super().m1()
        print('Class B, method 3')
    def m4(self):
        super().m2()
        print('Class B, method 4')

Polymorphism
Means that one thing can take multiple forms. Thinking about this literally, we human beings are polymorphic, we have different forms, as the situation changes, we change ourselves, the way we behave around friends, is not the same way we behave in the office.

In OOP therefore, objects can have multiple forms. There are 4 kinds of polymorphism:

Duck typing
Operator overloading
Method overloading
Method overriding

1. Duck typing
Here we have a function that takes an object and calls a method on it without caring about the object's type
Duck typing means that as long as the object has the required method, it can be used without caring about the object's type
Example: a duck and a dog can both have the quack() method and therefore can be treated the same in the code without checking for their specifc types

class Duck:
    def quack(self):
        return('Quack')
    
class Dog:
    def quack(self):
        return('Woof')

def make_sound(animal):
    animal.quack()

#creating the objects

duck = Duck()
dog = Dog()

print(dog.quack())
print(duck.quack())

Woof
Quack

#python functions displaying polymorphism

print(len('Data engineering'))
print(len([123, 456, 789, 102]))

16
4

The len function exhibits polymorphism because it can be used with different types of objects (strings and lists in this case) that provide the required len method.

This code demonstrates duck typing because it doesn't explicity check the object's class(it doesn't care).

2. Operator overloading
Arithmetic operations like +,-, *,/ are actions I can perform on objects
Operator loading therefore lets me define what those actions mean for instances of my own classes
This is done using 'add'

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    
    def __add__(self,other):
        return Point(self.x+other.x, self.y+other.y)


#creating two objects with the same blueprint

p1 = Point(2,3)
p2 = Point(3,4)

result = p1 + p2
print(result)

<__main__.Point object at 0x00000127606CBE80>

print(result.x, result.y)

5 7

3. Method overloading
Here we have a method with the capacity to house or take in different number of parameters - a very good example here is our round() method
Method overloading allows me to define multiple versions of a method with different parameter lists
When you call the method, the appropriate version is choosen based on the arguments you provide

#see what I mean

#first form - pass only the number you wish to round up - default state says it rounds the number to a whole number
check1 = round(45.9800001)
print(check1)

#second form - pass the number and the number of decimal places
check2 = round(45.98076512, 3)
print(check2)

46
45.981

#let me create something similar

class Calculator:
    def calculate(self, a, b=None):
        if b is None:
            return a*2
        else:
            return a*b
my_calc = Calculator()

print(my_calc.calculate(5))
print(my_calc.calculate(5,10))

10
50

4. Method overriding
First I have a parent class with a method
When I create a subclas, I can now define the same method with the same name
Method overriding means that I am replacing the parent's method with a new implementation in the subclass
This allows me to customize the behaviour of the method for the subclass without changing the parent's behaviour

class A:
    def m1(self):
        print('Class A, method 1')
    def m2(self):
        print('Class A, method 2')

class B(A):
    def m1(self):
        super().m1()
        print('I changed the output!')


b = B()

#method overriding in action
b.m1()

Class A, method 1
I changed the output!

Abstraction
This means hiding. It simplifies complex functionalities by focussing on what an object does rather than how it does it. It hides the inner workings of an object and exposes only the essential features you need to interact with it.

For example, the light switch is an abstracted object of all the internal workings behind it. We only know that when we flip the switch it either comes on or not.

Encapsulation
This hides data from external world. It protects the data within the class and exposes methods to the world.

1. Private methods

class Car:
    def __init__(self):
        self.__updateSoftware()
        
    def drive(self):
        print('Driving')
        
    def __updateSoftware(self):
        print('Updating software....')

myCar = Car()
myCar.drive()

Updating software
Driving

Updating software
Driving

class Car:
    __maxSpeed = 0
    __name = ''
    
    def __init__(self):
        self.__maxSpeed = 200
        self.__name = 'Super car'
    
    def drive(self):
        print('Max speed is: ', self.__maxSpeed)

myCar = Car()
myCar.drive()

Max speed is:  200

Using setter and getter

class Student:
    
    __college = 'LMN'
    def __init__(self, name, rno, marks):
        self.__name = name
        self.__rno = rno
        self.__marks = marks
        
    def display(self):
        print('Name: {}, Roll_number: {}, Marks: {}'.format(self.name, self.rno, self.marks))
        print('College:', self.__college)
        
    def setCollege(self, cname):
        self.__college = cname
        
    def getName(self):
        return self.__name

help(Student)

Help on class Student in module __main__:

class Student(builtins.object)
 |  Student(name, rno, marks)
 |  
 |  Methods defined here:
 |  
 |  __init__(self, name, rno, marks)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  display(self)
 |  
 |  getName(self)
 |  
 |  setCollege(self, cname)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)


Notice in the above that the __college data (it is a private variable remember) is not included in the docs when we called help(Student).

class Student2:
    
    __college = 'LMN'
    
    #I added a static variable here
    college2 = 'LMER'
    
    def __init__(self, name, rno, marks):
        self.__name = name
        self.__rno = rno
        self.__marks = marks
        
    def display(self):
        print('Name: {}, Roll_number: {}, Marks: {}'.format(self.name, self.rno, self.marks))
        print('College:', self.__college)
        
    def setCollege(self, cname):
        self.__college = cname
        
    def getName(self):
        return self.__name

help(Student2)

Help on class Student2 in module __main__:

class Student2(builtins.object)
 |  Student2(name, rno, marks)
 |  
 |  Methods defined here:
 |  
 |  __init__(self, name, rno, marks)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  display(self)
 |  
 |  getName(self)
 |  
 |  setCollege(self, cname)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  college2 = 'LMER'

Here, the data is shown here

Create a class Animal as a base class and define method animal_attribute. Create another class Tiger which is inheriting Animal and access the base class method.

class Animal:
    def animal_attribute(self, sound, color):
        self.sound = sound
        self.color = color
        return('My pet {} and is {} in color'.format(self.sound, self.color))

class Tiger(Animal):
    def new_func(self):
        print('New function')

pet = Tiger()

print(pet.animal_attribute('roars', 'black'))

My pet roars and is black in color

Create a class Cop. Initialize its name, age , work experience. Define methods to display and update the details. Create another class Mission which extends the class Cop. Define method add_mission _details. Select an object of Cop and access methods of base class to get information for a particular cop and make it available for mission.

class Cop:
    
    def __init__(self, name, age, work, experience):
        self.name = name
        self.age = age
        self.work = work
        self.experience = experience
    
    def display(self):
        return(self.name, self.age, self.work, self.experience)
    
    def update_details(self, name, age, work, experience):
        self.name = name
        self.age = age
        self.work = work
        self.experience = experience
        return 'Update completed!'
     
class Mission(Cop):
    def add_mission_details(self, country, LGA):
        self.country = country
        self.LGA = LGA
        print('Name: {}, Age: {}, Work: {}, Experience: {}'.format(self.name, self.age, self.work, self.experience))
        return('Posted to {} in {} LGA'.format(self.country, self.LGA))
         
police = Mission('Ken', 50, 'Director General', 'High')

print(police.add_mission_details('Nigeria', 'Chikun'))

Name: Ken, Age: 50, Work: Director General, Experience: High
Posted to Nigeria in Chikun LGA

